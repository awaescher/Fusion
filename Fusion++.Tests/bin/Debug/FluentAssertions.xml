<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FluentAssertions</name>
    </assembly>
    <members>
        <member name="M:FluentAssertions.AndConstraint`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="T:FluentAssertions.AndWhichConstraint`2">
            <summary>
            Constraint which can be returned from an assertion which matches a condition and which will allow
            further matches to be performed on the matched condition as well as the parent constraint.
            </summary>
            <typeparam name="TParentConstraint">The type of the original constraint that was matched</typeparam>
            <typeparam name="TMatchedElement">The type of the matched object which the parent constraint matched</typeparam>
        </member>
        <member name="P:FluentAssertions.AndWhichConstraint`2.Which">
            <summary>
            Returns the single result of a prior assertion that is used to select a nested or collection item.
            </summary>
        </member>
        <member name="P:FluentAssertions.AndWhichConstraint`2.Subject">
            <summary>
            Returns the single result of a prior assertion that is used to select a nested or collection item.
            </summary>
            <remarks>
            Just a convenience property that returns the same value as <see cref="P:FluentAssertions.AndWhichConstraint`2.Which"/>.
            </remarks>
        </member>
        <member name="T:FluentAssertions.AssertionExtensions">
            <summary>
            Contains extension methods for custom assertions in unit tests.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.ThrowExactly``1(FluentAssertions.Specialized.ActionAssertions,System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="actionAssertions"/> subject throws the exact exception (and not a derived exception type).
            </summary>
            <param name="actionAssertions">A reference to the method or property.</param>
            <typeparam name="TException">
            The type of the exception it should throw.
            </typeparam>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
            <returns>
            Returns an object that allows asserting additional members of the thrown exception.
            </returns>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.ThrowExactly``1(FluentAssertions.Specialized.AsyncFunctionAssertions,System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="asyncActionAssertions"/> subject throws the exact exception (and not a derived exception type).
            </summary>
            <param name="asyncActionAssertions">A reference to the method or property.</param>
            <typeparam name="TException">
            The type of the exception it should throw.
            </typeparam>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
            <returns>
            Returns an object that allows asserting additional members of the thrown exception.
            </returns>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Invoking``1(``0,System.Action{``0})">
            <summary>
            Invokes the specified action on an subject so that you can chain it with any of the ShouldThrow or ShouldNotThrow
            overloads.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.ExecutionTimeOf``1(``0,System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Provides methods for asserting the execution time of a method or property.
            </summary>
            <param name="subject">The object that exposes the method or property.</param>
            <param name="action">A reference to the method or property to measure the execution time of.</param>
            <returns>
            Returns an object for asserting that the execution time matches certain conditions.
            </returns>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.ExecutionTime(System.Action)">
            <summary>
            Provides methods for asserting the execution time of a method or property.
            </summary>
            <param name="action">A reference to the method or property to measure the execution time of.</param>
            <returns>
            Returns an object for asserting that the execution time matches certain conditions.
            </returns>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Specialized.ExecutionTime)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Specialized.ExecutionTimeAssertions"/> object that can be used to assert the
            current <see cref="M:FluentAssertions.AssertionExtensions.ExecutionTime(System.Action)"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Reflection.Assembly)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Reflection.AssemblyAssertions"/> object that can be used to assert the
            current <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Xml.Linq.XDocument)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Xml.XDocumentAssertions"/> object that can be used to assert the
            current <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Xml.Linq.XElement)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Xml.XElementAssertions"/> object that can be used to assert the
            current <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Xml.Linq.XAttribute)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Xml.XAttributeAssertions"/> object that can be used to assert the
            current <see cref="T:System.Xml.Linq.XAttribute"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Enumerating(System.Func{System.Collections.IEnumerable})">
            <summary>
            Forces enumerating a collection. Should be used to assert that a method that uses the
            <c>yield</c> keyword throws a particular exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Enumerating``1(System.Func{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Forces enumerating a collection. Should be used to assert that a method that uses the
            <c>yield</c> keyword throws a particular exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Object)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.ObjectAssertions"/> object that can be used to assert the
            current <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Boolean)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.BooleanAssertions"/> object that can be used to assert the
            current <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Boolean})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableBooleanAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.Boolean"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Guid)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.GuidAssertions"/> object that can be used to assert the
            current <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Guid})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableGuidAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Collections.IEnumerable)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.NonGenericCollectionAssertions"/> object that can be used to assert the
            current <see cref="T:System.Collections.IEnumerable"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.GenericCollectionAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.StringCollectionAssertions"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Collections.GenericDictionaryAssertions`2"/> object that can be used to assert the
            current <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.DateTime)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.DateTimeAssertions"/> object that can be used to assert the
            current <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.DateTimeOffset)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.DateTimeOffsetAssertions"/> object that can be used to assert the
            current <see cref="T:System.DateTimeOffset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.DateTime})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableDateTimeAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.DateTimeOffset})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.DateTimeOffset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should``1(System.IComparable{``0})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.ComparableTypeAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.IComparable`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Int32)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Int32})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Int32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.UInt32)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.UInt32})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.UInt32"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Decimal)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Decimal})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Decimal"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Byte)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Byte})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.SByte)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.SByte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.SByte})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.SByte"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Int16)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Int16})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Int16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.UInt16)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.UInt16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.UInt16})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.UInt16"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Int64)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Int64})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Int64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.UInt64)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.UInt64})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.UInt64"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Single)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Single})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Single"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Double)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that can be used to assert the
            current <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.Double})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Numeric.NullableNumericAssertions`1"/> object that can be used to assert the
            current nullable <see cref="T:System.Double"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.String)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.StringAssertions"/> object that can be used to assert the
            current <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.TimeSpan)">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.SimpleTimeSpanAssertions"/> object that can be used to assert the
            current <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Nullable{System.TimeSpan})">
            <summary>
            Returns an <see cref="T:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions"/> object that can be used to assert the
            current nullable <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Type)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.TypeAssertions"/> object that can be used to assert the
            current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Types.TypeSelector)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.TypeAssertions"/> object that can be used to assert the
            current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Reflection.ConstructorInfo)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.MethodBaseAssertions`2"/> object
            that can be used to assert the current <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Reflection.MethodInfo)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.MethodInfoAssertions"/> object that can be used to assert the current <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Types.MethodInfoSelector)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.MethodInfoSelectorAssertions"/> object that can be used to assert the methods returned by the
            current <see cref="T:FluentAssertions.Types.MethodInfoSelector"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Reflection.PropertyInfo)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.PropertyInfoAssertions"/> object that can be used to assert the
            current <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(FluentAssertions.Types.PropertyInfoSelector)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.PropertyInfoSelectorAssertions"/> object that can be used to assert the properties returned by the
            current <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/>.
            </summary>
            <seealso cref="T:FluentAssertions.Types.TypeAssertions"/>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Action)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Specialized.ActionAssertions"/> object that can be used to assert the
            current <see cref="T:System.Action"/> .
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Should(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Returns a <see cref="T:FluentAssertions.Specialized.AsyncFunctionAssertions"/> object that can be used to assert the
            current <see cref="T:System.Func`1"/> .
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.Monitor``1(``0,System.Func{System.DateTime})">
            <summary>
              Starts monitoring <paramref name="eventSource"/> for its events.
            </summary>
            <param name="eventSource">The object for which to monitor the events.</param>
            <param name="utcNow">
            An optional delegate that returns the current date and time in UTC format.
            Will revert to <see cref="P:System.DateTime.UtcNow"/> if no delegate was provided.
            </param>
            <exception cref = "T:System.ArgumentNullException">Thrown if <paramref name="eventSource"/> is Null.</exception>
        </member>
        <member name="M:FluentAssertions.AssertionExtensions.As``1(System.Object)">
            <summary>
            Safely casts the specified object to the type specified through <typeparamref name="TTo"/>.
            </summary>
            <remarks>
            Has been introduced to allow casting objects without breaking the fluent API.
            </remarks>
            <typeparam name="TTo"></typeparam>
        </member>
        <member name="T:FluentAssertions.AssertionOptions">
            <summary>
            Holds any global options that control the behavior of FluentAssertions.
            </summary>
        </member>
        <member name="M:FluentAssertions.AssertionOptions.AssertEquivalencyUsing(System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions,FluentAssertions.Equivalency.EquivalencyAssertionOptions})">
            <summary>
            Allows configuring the defaults used during a structural equivalency assertion.
            </summary>
            <param name="defaultsConfigurer">
            An action that is used to configure the defaults.
            </param>
        </member>
        <member name="P:FluentAssertions.AssertionOptions.EquivalencySteps">
            <summary>
            Represents a mutable collection of steps that are executed while asserting a (collection of) object(s)
            is structurally equivalent to another (collection of) object(s).
            </summary>
        </member>
        <member name="T:FluentAssertions.CallerIdentifier">
            <summary>
                Tries to extract the name of the variable or invocation on which the assertion is executed.
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.CollectionAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Collections.IEnumerable"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection contains at least 1 item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection is null or does not contain any items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the collection is not null and contains at least 1 item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.OnlyHaveUniqueItems(System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any duplicate items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotContainNulls(System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any <c>null</c> items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.Equal(System.Object[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by
            <paramref name="elements" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="elements">A params array with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.Equal(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by
            <paramref name="expected" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotEqual(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection not to contain all the same elements in the same order as the collection identified by
            <paramref name="unexpected" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.IEnumerable"/> with the elements that are not expected.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            Objects within the collections are equivalent when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.IEnumerable"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeEquivalentTo(System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            Objects within the collections are equivalent when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.IEnumerable"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            Objects within the collections are equivalent when both object graphs have equally named properties with the same
            value,  irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.IEnumerable"/> and all
            items in the collection are structurally equal.
            </remarks>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeEquivalentTo(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection not to contain all elements of the collection identified by <paramref name="unexpected" />,
            regardless of the order. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.IEnumerable"/> with the unexpected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.ContainItemsAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that the current collection only contains items that are assignable to the type <typeparamref name="T" />.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.Contain(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in any order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.ContainInOrder(System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order, not necessarily consecutive.
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.IEnumerable"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.ContainInOrder(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order, not necessarily consecutive.
            </summary>
            <remarks>
            Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </remarks>
            <param name="expected">An <see cref="T:System.Collections.IEnumerable"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeInAscendingOrder(System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in ascending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeInAscendingOrder(System.Collections.Generic.IComparer{System.Object},System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in ascending order. Elements are compared
            using the given <see cref="T:System.Collections.Generic.IComparer`1" /> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeInDescendingOrder(System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in descending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeInDescendingOrder(System.Collections.Generic.IComparer{System.Object},System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in descending order. Elements are compared
            using the given <see cref="T:System.Collections.Generic.IComparer`1" /> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeInOrder(System.Collections.Generic.IComparer{System.Object},FluentAssertions.Collections.SortOrder,System.String,System.Object[])">
            <summary>
            Expects the current collection to have all elements in the specified <paramref name="expectedOrder"/>.
            Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeAscendingInOrder(System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in ascending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeAscendingInOrder(System.Collections.Generic.IComparer{System.Object},System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in ascending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeDescendingInOrder(System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in descending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeDescendingInOrder(System.Collections.Generic.IComparer{System.Object},System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in descending order. Elements are compared
            using their <see cref="M:System.IComparable.CompareTo(System.Object)" /> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeInOrder(System.Collections.Generic.IComparer{System.Object},FluentAssertions.Collections.SortOrder,System.String,System.Object[])">
            <summary>
            Asserts the current collection does not have all elements in ascending order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.BeSubsetOf(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that the collection is a subset of the <paramref name="expectedSuperset" />.
            </summary>
            <param name="expectedSuperset">An <see cref="T:System.Collections.IEnumerable"/> with the expected superset.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotBeSubsetOf(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that the collection is not a subset of the <paramref name="unexpectedSuperset" />.
            </summary>
            <param name="unexpectedSuperset">An <see cref="T:System.Collections.IEnumerable"/> with the unexpected superset.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.HaveSameCount(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Assert that the current collection has the same number of elements as <paramref name="otherCollection" />.
            </summary>
            <param name="otherCollection">The other collection with the same expected number of elements</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotHaveSameCount(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Assert that the current collection does not have the same number of elements as <paramref name="otherCollection" />.
            </summary>
            <param name="otherCollection">The other collection with the unexpected number of elements</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.HaveElementAt(System.Int32,System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the current collection has the supplied <paramref name="element" /> at the
            supplied <paramref name="index" />.
            </summary>
            <param name="index">The index where the element is expected</param>
            <param name="element">The expected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotContain(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that the current collection does not contain the supplied items. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.IEnumerable"/> with the unexpected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.IntersectWith(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that the collection shares one or more items with the specified <paramref name="otherCollection"/>.
            </summary>
            <param name="otherCollection">The <see cref="T:System.Collections.IEnumerable"/> with the expected shared items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.NotIntersectWith(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that the collection does not share any items with the specified <paramref name="otherCollection"/>.
            </summary>
            <param name="otherCollection">The <see cref="T:System.Collections.IEnumerable"/> to compare to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.StartWith(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the collection starts with the specified <paramref name="element"/>.
            </summary>
            <param name="element">
            The element that is expected to appear at the start of the collection. The object's <see cref="M:System.Object.Equals(System.Object)"/>
            is used to compare the element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.EndWith(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the collection ends with the specified <paramref name="element"/>.
            </summary>
            <param name="element">
            The element that is expected to appear at the end of the collection. The object's <see cref="M:System.Object.Equals(System.Object)"/>
            is used to compare the element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.HaveElementPreceding(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="expectation"/> element directly precedes the <paramref name="successor"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.HaveElementSucceeding(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="expectation"/> element directly succeeds the <paramref name="predecessor"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.AllBeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that all items in the collection are of the specified type <typeparamref name="T" />
            </summary>
            <typeparam name="T">The expected type of the objects</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.AllBeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that all items in the collection are of the specified type <paramref name="expectedType"/>
            </summary>
            <param name="expectedType">The expected type of the objects</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.AllBeOfType``1(System.String,System.Object[])">
            <summary>
            Asserts that all items in the collection are of the exact specified type <typeparamref name="T" />
            </summary>
            <typeparam name="T">The expected type of the objects</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.CollectionAssertions`2.AllBeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that all items in the collection are of the exact specified type <paramref name="expectedType"/>
            </summary>
            <param name="expectedType">The expected type of the objects</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Collections.CollectionAssertions`2.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.NotContainNulls``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any <c>null</c> items.
            </summary>
            <param name="predicate">The predicate when evaluated should not be null.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.OnlyHaveUniqueItems``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any duplicate items.
            </summary>
            <param name="predicate">The predicate to group the items by.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.BeInAscendingOrder``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in ascending order according to the value of the specified
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="args">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.BeInAscendingOrder(System.Collections.Generic.IComparer{`0},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in ascending order according to the value of the specified
            <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="args">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.BeInAscendingOrder``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Collections.Generic.IComparer{``0},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in ascending order according to the value of the specified
            <paramref name="propertyExpression"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="args">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.BeInDescendingOrder``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in descending order according to the value of the specified
            <paramref name="propertyExpression"/>.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="args">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.BeInDescendingOrder(System.Collections.Generic.IComparer{`0},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in descending order according to the value of the specified
            <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="args">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.BeInDescendingOrder``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Collections.Generic.IComparer{``0},System.String,System.Object[])">
            <summary>
            Asserts that a collection is ordered in descending order according to the value of the specified
            <paramref name="propertyExpression"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> implementation.
            </summary>
            <param name="propertyExpression">
            A lambda expression that references the property that should be used to determine the expected ordering.
            </param>
            <param name="comparer">
            The object that should be used to determine the expected ordering.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="args">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.AllBeEquivalentTo``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that all elements in a collection of objects are equivalent to a given object.
            </summary>
            <remarks>
            Objects within the collection are equivalent to given object when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.IEnumerable"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericCollectionAssertions`1.AllBeEquivalentTo``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that all elements in a collection of objects are equivalent to a given object.
            </summary>
            <remarks>
            Objects within the collection are equivalent to given object when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.IEnumerable"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Collections.GenericDictionaryAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Collections.Generic.IDictionary`2"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.HaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the dictionary matches the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The expected number of items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotHaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the dictionary does not match the supplied <paramref name="unexpected" /> amount.
            </summary>
            <param name="unexpected">The unexpected number of items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.HaveCountGreaterThan(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the dictionary is greater than the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the dictionary will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.HaveCountGreaterOrEqualTo(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the dictionary is greater or equal to the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the dictionary will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.HaveCountLessThan(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the dictionary is less than the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the dictionary will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.HaveCountLessOrEqualTo(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the dictionary is less or equal to the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the dictionary will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.HaveCount(System.Linq.Expressions.Expression{System.Func{System.Int32,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the dictionary matches a condition stated by a predicate.
            </summary>
            <param name="countPredicate">The predicate which must be satisfied by the amount of items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the dictionary does not contain any items.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains at least 1 item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.Equal(System.Collections.Generic.IDictionary{`0,`1},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains all the same key-value pairs as the
            specified <paramref name="expected"/> dictionary. Keys and values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected dictionary</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotEqual(System.Collections.Generic.IDictionary{`0,`1},System.String,System.Object[])">
            <summary>
            Asserts the current dictionary not to contain all the same key-value pairs as the
            specified <paramref name="unexpected"/> dictionary. Keys and values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected dictionary</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.BeEquivalentTo``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that two dictionaries are equivalent.
            </summary>
            <remarks>
            The values within the dictionaries are equivalent when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of the values in the dictionaries are ignored as long as both dictionaries contain the same keys and
            the values for each key are structurally equivalent. Notice that actual behavior is determined by the global
            defaults managed by the <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </remarks>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.BeEquivalentTo``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that two dictionaries are equivalent.
            </summary>
            <remarks>
            The values within the dictionaries are equivalent when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of the values in the dictionaries are ignored as long as both dictionaries contain the same keys and
            the values for each key are structurally equivalent. Notice that actual behavior is determined by the global
            defaults managed by the <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </remarks>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainKey(`0,System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains the specified key. Keys are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected key</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainKeys(`0[])">
            <summary>
            Asserts that the dictionary contains all of the specified keys. Keys are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected keys</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainKeys(System.Collections.Generic.IEnumerable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains all of the specified keys. Keys are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected keys</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContainKey(`0,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="unexpected" /> key.
            Keys are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected key</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContainKeys(`0[])">
            <summary>
            Asserts that the dictionary does not contain any of the specified keys. Keys are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected keys</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContainKeys(System.Collections.Generic.IEnumerable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary does not contain any of the specified keys. Keys are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected keys</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainValue(`1,System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains the specified value. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainValues(`1[])">
            <summary>
            Asserts that the dictionary contains all of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected values</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.ContainValues(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary contains all of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected values</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.RepetitionPreservingIntersect(System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Returns an enumerable consisting of all items in the first collection also appearing in the second.
            </summary>
            <remarks>Enumerable.Intersect is not suitable because it drops any repeated elements.</remarks>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContainValue(`1,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="unexpected" /> value.
            Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContainValues(`1[])">
            <summary>
            Asserts that the dictionary does not contain any of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected values</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContainValues(System.Collections.Generic.IEnumerable{`1},System.String,System.Object[])">
            <summary>
            Asserts that the dictionary does not contain any of the specified values. Values are compared using
            their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected values</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.Contain(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="expected"/>.
            Keys and values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected key/value pairs.</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.Contain(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="expected"/>.
            Keys and values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected key/value pairs.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.Contain(System.Collections.Generic.KeyValuePair{`0,`1},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="expected"/>.
            Keys and values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected <see cref="T:System.Collections.Generic.KeyValuePair`2"/></param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.Contain(`0,`1,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary contains the specified <paramref name="value" /> for the supplied
            <paramref name="key" />. Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="key">The key for which to validate the value</param>
            <param name="value">The value to validate</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContain(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="items"/>.
            Keys and values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="items">The unexpected key/value pairs</param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContain(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="items"/>.
            Keys and values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="items">The unexpected key/value pairs</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContain(System.Collections.Generic.KeyValuePair{`0,`1},System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="item"/>.
            Keys and values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="item">The unexpected <see cref="T:System.Collections.Generic.KeyValuePair`2"/></param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.GenericDictionaryAssertions`2.NotContain(`0,`1,System.String,System.Object[])">
            <summary>
            Asserts that the current dictionary does not contain the specified <paramref name="value" /> for the
            supplied <paramref name="key" />. Values are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="key">The key for which to validate the value</param>
            <param name="value">The value to validate</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Collections.GenericDictionaryAssertions`2.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Collections.NonGenericCollectionAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Collections.IEnumerable"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.HaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The expected number of items in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.NotHaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection does not match the supplied <paramref name="unexpected" /> amount.
            </summary>
            <param name="unexpected">The unexpected number of items in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.HaveCountGreaterThan(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is greater than the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.HaveCountGreaterOrEqualTo(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is greater or equal to the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.HaveCountLessThan(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is less than the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.HaveCountLessOrEqualTo(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is less or equal to the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.HaveCount(System.Linq.Expressions.Expression{System.Func{System.Int32,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches a condition stated by the <paramref name="countPredicate"/>.
            </summary>
            <param name="countPredicate">A predicate that yields the number of items that is expected to be in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.Contain(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the current collection contains the specified <paramref name="expected"/> object. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">An object, or <see cref="T:System.Collections.IEnumerable"/> of objects that are expected to be in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.NotContain(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that the current collection does not contain the supplied <paramref name="unexpected" /> item.
            Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The element that is not expected to be in the collection</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.BeEquivalentTo(System.Collections.IEnumerable,System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            Objects within the collections are equivalent when both object graphs have equally named properties with the same
            value, irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.IEnumerable"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.NonGenericCollectionAssertions.BeEquivalentTo(System.Collections.IEnumerable,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{System.Collections.IEnumerable},FluentAssertions.Equivalency.EquivalencyAssertionOptions{System.Collections.IEnumerable}},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            Objects within the collections are equivalent when both object graphs have equally named properties with the same
            value,  irrespective of the type of those objects. Two properties are also equal if one type can be converted to another
            and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.IEnumerable"/> and all
            items in the collection are structurally equal.
            </remarks>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Collections.Generic.IEnumerable`1"/> is in the expectation state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.HaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The expected number of items in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.HaveCount(System.Linq.Expressions.Expression{System.Func{System.Int32,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection matches a condition stated by the <paramref name="countPredicate"/>.
            </summary>
            <param name="countPredicate">A predicate that yields the number of items that is expected to be in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.NotHaveCount(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection does not match the supplied <paramref name="unexpected" /> amount.
            </summary>
            <param name="unexpected">The unexpected number of items in the collection.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.HaveCountGreaterThan(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is greater than the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.HaveCountGreaterOrEqualTo(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is greater or equal to the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.HaveCountLessThan(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is less than the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.HaveCountLessOrEqualTo(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the number of items in the collection is less or equal to the supplied <paramref name="expected" /> amount.
            </summary>
            <param name="expected">The number to which the actual number items in the collection will be compared.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Equal(`0[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by
            <paramref name="elements" />. Elements are compared using their <see cref="!:T.Equals(object)" /> method.
            </summary>
            <param name="elements">A params array with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Func{`0,``0,System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that two collections contain the same items in the same order, where equality is determined using a
            <paramref name="equalityComparison"/>.
            </summary>
            <param name="expectation">
            The collection to compare the subject with.
            </param>
            <param name="equalityComparison">
            A equality comparison the is used to determine whether two objects should be treated as equal.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.StartWith(System.Collections.Generic.IEnumerable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the current collection starts with same elements in the same order as the collection identified by
            <paramref name="expectation" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expectation">
            A collection of expected elements.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.StartWith``1(System.Collections.Generic.IEnumerable{``0},System.Func{`0,``0,System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that the current collection starts with same elements in the same order as the collection identified by
            <paramref name="expectation" />. Elements are compared using <paramref name="equalityComparison"/>.
            </summary>
            <param name="expectation">
            A collection of expected elements.
            </param>
            <param name="equalityComparison">
            A equality comparison the is used to determine whether two objects should be treated as equal.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.EndWith(System.Collections.Generic.IEnumerable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the current collection ends with same elements in the same order as the collection identified by
            <paramref name="expectation" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expectation">
            A collection of expected elements.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.EndWith``1(System.Collections.Generic.IEnumerable{``0},System.Func{`0,``0,System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that the current collection ends with same elements in the same order as the collection identified by
            <paramref name="expectation" />. Elements are compared using <paramref name="equalityComparison"/>.
            </summary>
            <param name="expectation">
            A collection of expected elements.
            </param>
            <param name="equalityComparison">
            A equality comparison the is used to determine whether two objects should be treated as equal.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Contain(`0,System.String,System.Object[])">
            <summary>
            Asserts that the collection contains the specified item.
            </summary>
            <param name="expected">The expectation item.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Contain(System.Collections.Generic.IEnumerable{`0},`0[])">
            <summary>
            Asserts that the collection contains some extra items in addition to the original items.
            </summary>
            <param name="expectedItemsList">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of expectation items.</param>
            <param name="additionalExpectedItems">Additional items that are expectation to be contained by the collection.</param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.Contain(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the collection contains at least one item that matches the predicate.
            </summary>
            <param name="predicate">A predicate to match the items in the collection against.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.OnlyContain(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the collection only contains items that match a predicate.
            </summary>
            <param name="predicate">A predicate to match the items in the collection against.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.NotContain(`0,System.String,System.Object[])">
            <summary>
            Asserts that the current collection does not contain the supplied <paramref name="unexpected" /> item.
            </summary>
            <param name="unexpected">The element that is not expected to be in the collection</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.NotContain(System.Collections.Generic.IEnumerable{`0},`0[])">
            <summary>
            Asserts that the collection does not contain some extra items in addition to the original items.
            </summary>
            <param name="unexpectedItemsList">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of unexpected items.</param>
            <param name="additionalUnexpectedItems">Additional items that are not expected to be contained by the collection.</param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.NotContain(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the collection does not contain any items that match the predicate.
            </summary>
            <param name="predicate">A predicate to match the items in the collection against.</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.ContainSingle(System.String,System.Object[])">
            <summary>
            Expects the current collection to contain only a single item.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.SelfReferencingCollectionAssertions`2.ContainSingle(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Expects the current collection to contain only a single item matching the specified <paramref name="predicate"/>.
            </summary>
            <param name="predicate">The predicate that will be used to find the matching items.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Equal(System.String[])">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by
            <paramref name="expected" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Equal(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Expects the current collection to contain all the same elements in the same order as the collection identified by
            <paramref name="expected" />. Elements are compared using their <see cref="M:System.Object.Equals(System.Object)" />.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.BeEquivalentTo(System.String[])">
            <summary>
            Asserts that a collection of string is equivalent to another collection of strings.
            </summary>
            <remarks>
            The two collections are equivalent when they both contain the same strings in any order.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.BeEquivalentTo(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            The two collections are equivalent when they both contain the same strings in any order.
            </remarks>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.BeEquivalentTo(System.Collections.Generic.IEnumerable{System.String},System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{System.String},FluentAssertions.Equivalency.EquivalencyAssertionOptions{System.String}},System.String,System.Object[])">
            <summary>
            Asserts that a collection of objects is equivalent to another collection of objects.
            </summary>
            <remarks>
            The two collections are equivalent when they both contain the same strings in any order.
            </remarks>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.ContainInOrder(System.String[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.ContainInOrder(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in the exact same order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Contain(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Expects the current collection to contain the specified elements in any order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the expected elements.</param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.Contain(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object,System.Object[])">
            <summary>
            Expects the current collection to contain the specified elements in any order. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> with the expected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Collections.StringCollectionAssertions.NotContain(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object,System.Object[])">
            <summary>
            Asserts that the current collection does not contain the supplied items. Elements are compared
            using their <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the unexpected elements.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Collections.WhichValueConstraint`2.WhichValue">
            <summary>
            Gets the value of the object referred to by the key.
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.Current">
            <summary>
            Gets the active configuration,
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.ValueFormatterDetectionMode">
            <summary>
            Gets or sets the mode on how Fluent Assertions will find custom implementations of
            <see cref="T:FluentAssertions.Formatting.IValueFormatter"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.ValueFormatterAssembly">
            <summary>
            Gets or sets the assembly name to scan for custom value formatters in case <see cref="P:FluentAssertions.Common.Configuration.ValueFormatterDetectionMode"/>
            is set to <see cref="F:FluentAssertions.Common.ValueFormatterDetectionMode.Specific"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Common.Configuration.TestFrameworkName">
            <summary>
            Gets or sets the name of the test framework to use.
            </summary>
            <remarks>
            If no name is provided, Fluent Assertions
            will try to detect it by scanning the currently loaded assemblies. If it can't find a suitable provider,
            and the run-time platform supports it, it'll try to get it from the <see cref="T:FluentAssertions.Common.IConfigurationStore"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Common.DateTimeExtensions.ToDateTimeOffset(System.DateTime)">
            <summary>
            Converts an existing <see cref="T:System.DateTime"/> to a <see cref="T:System.DateTimeOffset"/> but normalizes the <see cref="T:System.DateTimeKind"/>
            so that comparisons of converted <see cref="T:System.DateTime"/> instances retain the UTC/local agnostic behavior.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.EnumerableExtensions.IndexOfFirstDifferenceWith``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,System.Boolean})">
            <summary>
            Searches for the first different element in two sequences using specified <paramref name="equalityComparison" />
            </summary>
            <typeparam name="TFirst">The type of the elements of the <paramref name="first" /> sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the <paramref name="second" /> sequence.</typeparam>
            <param name="first">The first sequence to compare.</param>
            <param name="second">The second sequence to compare.</param>
            <param name="equalityComparison">Method that is used to compare 2 elements with the same index.</param>
            <returns>Index at which two sequences have elements that are not equal, or -1 if enumerables are equal</returns>
        </member>
        <member name="M:FluentAssertions.Common.ExpressionExtensions.GetMemberPath``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets a dotted path of property names representing the property expression. E.g. Parent.Child.Sibling.Name.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.MethodInfoExtensions.ImplementationOptionsMask">
            <summary>
            A sum of all possible <see cref="T:System.Runtime.CompilerServices.MethodImplOptions"/>. It's needed to calculate what options were used when decorating with <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute"/>.
            They are a subset of <see cref="T:System.Reflection.MethodImplAttributes"/> which can be checked on a type and therefore this mask has to be applied to check only for options.
            </summary>
        </member>
        <member name="T:FluentAssertions.Common.Services">
            <summary>
            Maintains the framework-specific services.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.IndexOfFirstMismatch(System.String,System.String)">
            <summary>
            Finds the first index at which the <paramref name="value"/> does not match the <paramref name="expected"/>
            string anymore, including the exact casing.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.IndexOfFirstMismatch(System.String,System.String,System.StringComparison)">
            <summary>
            Finds the first index at which the <paramref name="value"/> does not match the <paramref name="expected"/>
            string anymore, accounting for the specified <paramref name="stringComparison"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.IndexedSegmentAt(System.String,System.Int32)">
            <summary>
            Gets the quoted three characters at the specified index of a string, including the index itself.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.Escape(System.String,System.Boolean)">
            <summary>
            Replaces all characters that might conflict with formatting placeholders and newlines with their escaped counterparts.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.Unescape(System.String,System.Boolean)">
            <summary>
            Replaces all characters that might conflict with formatting placeholders and newlines with their escaped counterparts.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.Combine(System.String,System.String,System.String)">
            <summary>
            Joins a string with one or more other strings using a specified separator.
            </summary>
            <remarks>
            Any string that is empty (including the original string) is ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Common.StringExtensions.Capitalize(System.String)">
            <summary>
            Changes the first character of a string to uppercase.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary>
                Determines whether the specified method has been annotated with a specific attribute.
            </summary>
            <returns>
                <c>true</c> if the specified method has attribute; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.IsEquivalentTo(FluentAssertions.Equivalency.SelectedMemberInfo,FluentAssertions.Equivalency.SelectedMemberInfo)">
            <summary>
                Determines whether two <see cref="T:FluentAssertions.Equivalency.SelectedMemberInfo" /> objects refer to the same
                member.
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
                NOTE: This method does not give the expected results with open generics
            </summary>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.FindMember(System.Type,System.String,System.Type)">
            <summary>
                Finds a member by its case-sensitive name.
            </summary>
            <returns>
                Returns <c>null</c> if no such member exists.
            </returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.FindProperty(System.Type,System.String,System.Type)">
            <summary>
                Finds the property by a case-sensitive name.
            </summary>
            <returns>
                Returns <c>null</c> if no such property exists.
            </returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.FindField(System.Type,System.String,System.Type)">
            <summary>
                Finds the field by a case-sensitive name.
            </summary>
            <returns>
                Returns <c>null</c> if no such property exists.
            </returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.IsCSharpAbstract(System.Type)">
            <summary>
            Check if the type is declared as abstract.
            </summary>
            <param name="type">Type to be checked</param>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.IsCSharpSealed(System.Type)">
            <summary>
            Check if the type is declared as sealed.
            </summary>
            <param name="type">Type to be checked</param>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Common.TypeExtensions.IsCSharpStatic(System.Type)">
            <summary>
            Check if the type is declared as static.
            </summary>
            <param name="type">Type to be checked</param>
            <returns></returns>
        </member>
        <member name="T:FluentAssertions.Common.ValueFormatterDetectionMode">
            <summary>
            Defines the modes in which custom implementations of <see cref="T:FluentAssertions.Formatting.IValueFormatter"/>
            are detected as configured through <see cref="P:FluentAssertions.Common.Configuration.ValueFormatterDetectionMode"/>.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.ValueFormatterDetectionMode.Disabled">
            <summary>
            Detection is disabled.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.ValueFormatterDetectionMode.Specific">
            <summary>
            Only custom value formatters exposed through the assembly set in <see cref="P:FluentAssertions.Common.Configuration.ValueFormatterAssembly"/>
            are detected.
            </summary>
        </member>
        <member name="F:FluentAssertions.Common.ValueFormatterDetectionMode.Scan">
            <summary>
            All custom value formatters in any assembly loaded in the current <see cref="T:System.AppDomain"/> will be detected.
            </summary>
        </member>
        <member name="T:FluentAssertions.CustomAssertionAttribute">
            <summary>
            Marks a method as an extension to Fluent Assertions that either uses the built-in assertions
            internally, or directly uses the <c>Execute.Assertion</c>.
            </summary>
        </member>
        <member name="T:FluentAssertions.EquivalencyStepCollection">
            <summary>
            Represents a mutable collection of equivalency steps that can be reordered and/or amended with additional
            custom equivalency steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.Add``1">
            <summary>
            Adds a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> after any of the built-in steps, with the exception of the final
            <see cref="T:FluentAssertions.Equivalency.SimpleEqualityEquivalencyStep"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.AddAfter``2">
            <summary>
            Adds a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> right after the specified <typeparamref name="TPredecessor"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.Insert``1">
            <summary>
            Inserts a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> before any of the built-in steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.InsertBefore``2">
            <summary>
            Inserts a new <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/> just before the <typeparamref name="TSuccessor"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.Remove``1">
            <summary>
            Removes all instances of the specified <typeparamref name="TStep"/> from the current step.
            </summary>
        </member>
        <member name="M:FluentAssertions.EquivalencyStepCollection.Clear">
            <summary>
            Removes each and every built-in <see cref="T:FluentAssertions.Equivalency.IEquivalencyStep"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.AssertionResultSet">
            <summary>
            Represents a collection of assertion results obtained through a <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionResultSet.AddSet(System.Object,System.String[])">
            <summary>
            Adds the failures (if any) resulting from executing an assertion within a
             <see cref="T:FluentAssertions.Execution.AssertionScope"/> identified by a key.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionResultSet.SelectClosestMatchFor(System.Object)">
            <summary>
            Returns  the closest match compared to the set identified by the provided <paramref name="key"/> or
            an empty array if one of the results represents a successful assertion.
            </summary>
            <remarks>
             The closest match is the set that contains the least amount of failures, or no failures at all, and preferably
            the set that is identified by the <paramref name="key"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionResultSet.ContainsSuccessfulSet">
            <summary>
            Gets a value indicating whether this collection contains a set without any failures at all.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.AssertionRule`1">
            <summary>
            General purpose implementation of <see cref="T:FluentAssertions.Equivalency.IAssertionRule"/> that uses a predicate to determine whether
            this rule applies to a particular property and executes an action to assert equality.
            </summary>
            <typeparam name="TSubject">The type of the subject.</typeparam>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionRule`1.AssertEquality(FluentAssertions.Equivalency.IEquivalencyValidationContext)">
            <summary>
            Defines how a subject's property is compared for equality with the same property of the expectation.
            </summary>
            <returns>
            Returns <c>true</c> if the rule was applied correctly and the assertion didn't cause any exceptions.
            Returns <c>false</c> if this rule doesn't support the subject's type.
            Throws if the rule did support the data type but assertion fails.
            </returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionRule`1.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.AssertionRuleEquivalencyStep`1.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.AssertionRuleEquivalencyStepAdapter">
            <summary>
            Adapter allowing an IAssertionRule to be used where a IEquivalencyStep is required.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.ConversionSelector">
            <summary>
            Collects the members that need to be converted by the <see cref="T:FluentAssertions.Equivalency.TryConversionStep"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.CyclicReferenceDetector">
            <summary>
            Keeps track of objects and their location within an object graph so that cyclic references can be detected
            and handled upon.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.CyclicReferenceDetector.IsCyclicReference(FluentAssertions.Equivalency.ObjectReference)">
            <summary>
            Determines whether the specified object reference is a cyclic reference to the same object earlier in the
            equivalency validation.
            </summary>
            <remarks>
            The behavior of a cyclic reference is determined by the <see cref="T:FluentAssertions.Equivalency.CyclicReferenceHandling"/> constructor
            parameter.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.CyclicReferenceDetector.Clone">
             <summary>
             Creates a new object that is a copy of the current instance.
             </summary>
            
             <returns>
             A new object that is a copy of this instance.
             </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.CyclicReferenceHandling">
            <summary>
            Indication of how cyclic references should be handled when validating equality of nested properties.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.CyclicReferenceHandling.Ignore">
            <summary>
            Cyclic references will be ignored.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.CyclicReferenceHandling.ThrowException">
            <summary>
            Cyclic references will result in an exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.DictionaryEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.DictionaryEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EnumEqualityStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EnumEqualityStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EnumerableEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the verificationScope subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EnumerableEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.EnumerableEquivalencyValidator">
            <summary>
            Executes a single equivalency assertion on two collections, optionally recursive and with or without strict ordering.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1">
            <summary>
            Represents the run-time type-specific behavior of a structural equivalency assertion.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Excludes the specified (nested) member from the structural equality check.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Including(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Includes the specified member in the equality check.
            </summary>
            <remarks>
            This overrides the default behavior of including all declared members.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.Including(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
            Includes the specified member in the equality check.
            </summary>
            <remarks>
            This overrides the default behavior of including all declared members.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.WithStrictOrderingFor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Causes the collection identified by <paramref name="expression"/> to be compared in the order
            in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1.AsCollection">
            <summary>
            Creates a new set of options based on the current instance which acts on a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions">
            <summary>
            Represents the run-time type-agnostic behavior of a structural equivalency assertion.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.EquivalencyAssertionOptionsExtentions.GetExpectationType(FluentAssertions.Equivalency.IEquivalencyAssertionOptions,FluentAssertions.Equivalency.IMemberInfo)">
            <summary>
                Returns either the run-time or compile-time type of the subject based on the options provided by the caller.
            </summary>
            <remarks>
            If the expectation is a nullable type, it should return the type of the wrapped object.
            </remarks>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.Subject">
            <summary>
            Gets the value of the <see cref="P:FluentAssertions.Equivalency.IMemberInfo.SelectedMemberInfo" />
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.Expectation">
            <summary>
            Gets the value of the <see cref="!:IEquivalencyValidationContext.MatchingExpectationProperty" />.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.Because">
            <summary>
              A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
              is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.BecauseArgs">
            <summary>
              Zero or more objects to format using the placeholders in <see cref="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Because" />.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.IsRoot">
            <summary>
              Gets a value indicating whether the current context represents the root of the object graph.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.CompileTimeType">
            <summary>
            Gets the compile-time type of the current expectation object. If the current object is not the root object
            and the type is not <see cref="T:System.Object"/>,  then it returns the same <see cref="T:System.Type"/>
            as the <see cref="P:FluentAssertions.Equivalency.IMemberInfo.RuntimeType"/> property does.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.RuntimeType">
            <summary>
            Gets the run-time type of the current expectation object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.EquivalencyValidationContext.RootIsCollection">
            <summary>
            Gets or sets a value indicating that the root of the graph is a collection so all type-specific options apply on
            the collection type and not on the root itself.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.EquivalencyValidator">
            <summary>
            Is responsible for validating the equality of one or more properties of a subject with another object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.FieldSelectedMemberInfo">
            <summary>
            Provides an ISelectedMemberInfo for FieldInfo objects
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.GenericDictionaryEquivalencyStep">
            <remarks>
                I think (but did not try) this would have been easier using 'dynamic' but that is
                precluded by some of the PCL targets.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.GenericEnumerableEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the verificationScope subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.GenericEnumerableEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.IAssertionContext`1">
            <summary>
            Provides the required information for executing an equality assertion between a subject and an expectation.
            </summary>
            <typeparam name="TSubject">The type of the subject.</typeparam>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.SubjectProperty">
            <summary>
            Gets the <see cref="T:FluentAssertions.Equivalency.SelectedMemberInfo"/> of the member that returned the current object, or <c>null</c> if the current
            object represents the root object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.Subject">
            <summary>
            Gets the value of the <see cref="P:FluentAssertions.Equivalency.IAssertionContext`1.SubjectProperty" />
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.Expectation">
            <summary>
            Gets the value of the expectation object that was matched with the subject using a <see cref="T:FluentAssertions.Equivalency.IMemberMatchingRule"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.Because">
            <summary>
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IAssertionContext`1.BecauseArgs">
            <summary>
            Zero or more objects to format using the placeholders in <see cref="P:FluentAssertions.Equivalency.IAssertionContext`1.Because"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IAssertionRule.AssertEquality(FluentAssertions.Equivalency.IEquivalencyValidationContext)">
            <summary>
            Defines how a subject's property is compared for equality with the same property of the expectation.
            </summary>
            <returns>
            Returns <c>true</c> if the rule was applied correctly and the assertion didn't cause any exceptions.
            Returns <c>false</c> if this rule doesn't support the subject's type.
            Throws if the rule did support the data type but assertion fails.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.IEquivalencyAssertionOptions">
            <summary>
            Provides the run-time details of the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1" /> class.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.SelectionRules">
            <summary>
            Gets an ordered collection of selection rules that define what properties are included.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.MatchingRules">
            <summary>
            Gets an ordered collection of matching rules that determine which subject properties are matched with which
            expectation properties.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IsRecursive">
            <summary>
            Gets a value indicating whether or not the assertion must perform a deep comparison.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.AllowInfiniteRecursion">
            <summary>
            Gets a value indicating whether recursion is allowed to continue indefinitely.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.CyclicReferenceHandling">
            <summary>
            Gets value indicating how cyclic references should be handled. By default, it will throw an exception.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.OrderingRules">
            <summary>
            Gets an ordered collection of rules that determine whether or not the order of collections is important. By default,
            ordering is irrelevant.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.ConversionSelector">
            <summary>
            Contains the rules for what properties to run an auto-conversion.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.EnumEquivalencyHandling">
            <summary>
            Gets value indicating how the enums should be compared.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.UserEquivalencySteps">
            <summary>
            Gets an ordered collection of Equivalency steps how a subject is compared with the expectation.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.UseRuntimeTyping">
            <summary>
            Gets a value indicating whether the runtime type of the expectation should be used rather than the declared type.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludeProperties">
            <summary>
            Gets a value indicating whether properties should be considered.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludeFields">
            <summary>
            Gets a value indicating whether fields should be considered.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.TraceWriter">
            <summary>
            Gets the currently configured tracer, or <c>null</c> if no tracing was configured.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyAssertionOptions.GetEqualityStrategy(System.Type)">
            <summary>
            Determines the right strategy for evaluating the equality of objects of this type.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EqualityStrategy.Equals">
            <summary>
            The object overrides <see cref="M:System.Object.Equals(System.Object)"/>, so use that.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EqualityStrategy.Members">
            <summary>
            The object does not seem to override <see cref="M:System.Object.Equals(System.Object)"/>, so compare by members
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EqualityStrategy.ForceEquals">
            <summary>
            Compare using <see cref="M:System.Object.Equals(System.Object)"/>, whether or not the object overrides it.
            </summary>
        </member>
        <member name="F:FluentAssertions.Equivalency.EqualityStrategy.ForceMembers">
            <summary>
            Compare the members, regardless of an <see cref="M:System.Object.Equals(System.Object)"/> override exists or not.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IEquivalencyStep">
            <summary>
            Defines a step in the process of comparing two object graphs for structural equivalency.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.IEquivalencyValidationContext">
            <summary>
            Provides information on a particular property during an assertion for structural equality of two object graphs.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Expectation">
            <summary>
            Gets the value of the <see cref="!:MatchingExpectationProperty"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Because">
            <summary>
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.BecauseArgs">
            <summary>
            Zero or more objects to format using the placeholders in <see cref="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Because"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.IsRoot">
            <summary>
            Gets a value indicating whether the current context represents the root of the object graph.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Subject">
            <summary>
            Gets the value of the <see cref="!:ISelectionContext.PropertyInfo"/>
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.RootIsCollection">
            <summary>
            Gets or sets a value indicating that the root of the graph is a collection so all type-specific options apply on
            the collection type and not on the root itself.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Tracer">
            <summary>
            Gets or sets the current trace writer or <c>null</c> if no tracing has been enabled.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyValidationContext.TraceBlock(FluentAssertions.Equivalency.GetTraceMessage)">
            <summary>
            Starts a block that scopes an operation that will be written to the currently configured <see cref="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Tracer"/>
            after the returned disposable is disposed..
            </summary>
            <remarks>
            If no tracer has been configured, the call will be ignored.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.IEquivalencyValidationContext.TraceSingle(FluentAssertions.Equivalency.GetTraceMessage)">
            <summary>
            Writes a single line to the currently configured <see cref="P:FluentAssertions.Equivalency.IEquivalencyValidationContext.Tracer"/>.
            </summary>
            <remarks>
            If no tracer has been configured, the call will be ignored.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.GetTraceMessage">
            <summary>
            Defines a function that takes the current path and returns the trace message to log.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMemberInfo">
            <summary>
            Provides details about the expectation's root or nested member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.SelectedMemberInfo">
            <summary>
            Gets the <see cref="P:FluentAssertions.Equivalency.IMemberInfo.SelectedMemberInfo"/> of the member that returned the current object, or <c>null</c> if the current
            object represents the root object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.SelectedMemberPath">
            <summary>
            Gets the full path from the root object until the current object separated by dots.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.SelectedMemberDescription">
            <summary>
            Gets a display-friendly representation of the <see cref="P:FluentAssertions.Equivalency.IMemberInfo.SelectedMemberPath"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.CompileTimeType">
            <summary>
            Gets the compile-time type of the current object. If the current object is not the root object and the type is not <see cref="T:System.Object"/>,
            then it returns the same <see cref="T:System.Type"/> as the <see cref="P:FluentAssertions.Equivalency.IMemberInfo.RuntimeType"/> property does.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberInfo.RuntimeType">
            <summary>
            Gets the run-time type of the current object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMemberMatchingRule">
            <summary>
            Represents a rule that defines how to map the selected members of the expectation object to the properties
            of the subject.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IMemberMatchingRule.Match(FluentAssertions.Equivalency.SelectedMemberInfo,System.Object,System.String,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Attempts to find a member on the subject that should be compared with the
            <paramref name="expectedMember"/> during a structural equality.
            </summary>
            <remarks>
            Whether or not a match is required or optional is up to the specific rule. If no match is found and this is not an issue,
            simply return <c>null</c>.
            </remarks>
            <param name="expectedMember">
            The <see cref="T:FluentAssertions.Equivalency.SelectedMemberInfo"/> of the subject's member for which a match must be found. Can never
            be <c>null</c>.
            </param>
            <param name="subject">
            The subject object for which a matching member must be returned. Can never be <c>null</c>.
            </param>
            <param name="memberPath">
            The dotted path from the root object to the current member. Will never  be <c>null</c>.
            </param>
            <param name="config"></param>
            <returns>
            Returns the <see cref="T:FluentAssertions.Equivalency.SelectedMemberInfo"/> of the property with which to compare the subject with, or <c>null</c>
            if no match was found.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.IMemberSelectionRule">
            <summary>
            Represents a rule that defines which members of the subject-under-test to include while comparing
            two objects for structural equality.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.IMemberSelectionRule.IncludesMembers">
            <summary>
            Gets a value indicating whether this rule should override the default selection rules that include all members.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IMemberSelectionRule.SelectMembers(System.Collections.Generic.IEnumerable{FluentAssertions.Equivalency.SelectedMemberInfo},FluentAssertions.Equivalency.IMemberInfo,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Adds or removes properties to/from the collection of subject members that must be included while
            comparing two objects for structural equality.
            </summary>
            <param name="selectedMembers">
                A collection of members that was prepopulated by other selection rules. Can be empty.</param>
            <param name="context"></param>
            <param name="config"></param>
            <param name="info">
            Type info about the subject.
            </param>
            <returns>
            The collection of members after applying this rule. Can contain less or more than was passed in.
            </returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.IOrderingRule">
            <summary>
            Defines a rule that is used to determine whether the order of items in collections is relevant or not.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.IOrderingRule.Evaluate(FluentAssertions.Equivalency.IMemberInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="memberInfo"/> is relevant.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Matching.MustMatchByNameRule">
            <summary>
            Requires the expectation object to have a member with the exact same name.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Matching.MustMatchByNameRule.ToString">
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Matching.TryMatchByNameRule">
            <summary>
            Finds a member of the expectation with the exact same name, but doesn't require it.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Matching.TryMatchByNameRule.ToString">
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.MemberInfoSelectedMemberInfo">
            <summary>
            A partial ISelectedMemberInfo implementation that delegates to a MemberInfo object
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.MultiDimensionalArrayEquivalencyStep">
            <summary>
            Supports recursively comparing two multi-dimensional arrays for equivalency using strict order for the array items
            themselves.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.ObjectReference">
            <summary>
            Represents  an object tracked by the <see cref="T:FluentAssertions.Equivalency.CyclicReferenceDetector"/> including it's location within an object graph.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ObjectReference.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.ObjectReference.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.OrderingRuleCollection">
            <summary>
            Collection of <see cref="T:FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule"/>s.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.#ctor">
            <summary>
            Initializes a new collection of ordering rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.#ctor(System.Collections.Generic.IEnumerable{FluentAssertions.Equivalency.IOrderingRule})">
            <summary>
            Initializes a new collection of ordering rules based on an existing collection of ordering rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:FluentAssertions.Equivalency.OrderingRuleCollection.IsOrderingStrictFor(FluentAssertions.Equivalency.IMemberInfo)">
            <summary>
            Determines whether the rules in this collection dictate strict ordering during the equivalency assertion on
            the collection pointed to by <paramref name="memberInfo"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Ordering.ByteArrayOrderingRule">
            <summary>
            Ordering rule that ensures that byte arrays are always compared in strict ordering since it would cause a
            severe performance impact otherwise.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Ordering.MatchAllOrderingRule">
            <summary>
            An ordering rule that basically states that the order of items in all collections is important.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Ordering.MatchAllOrderingRule.Evaluate(FluentAssertions.Equivalency.IMemberInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="memberInfo"/> is relevant.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule">
            <summary>
            Represents a rule for determining whether or not a certain collection within the object graph should be compared using
            strict ordering.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule.Evaluate(FluentAssertions.Equivalency.IMemberInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="memberInfo"/> is relevant.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Ordering.PredicateBasedOrderingRule.Evaluate(FluentAssertions.Equivalency.IMemberInfo)">
            <summary>
            Determines if ordering of the member referred to by the current <paramref name="memberInfo"/> is relevant.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.PropertySelectedMemberInfo">
            <summary>
            Provides an ISelectedMemberInfo for PropertyInfo objects
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ReferenceEqualityEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ReferenceEqualityEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.RunAllUserStepsEquivalencyStep">
            <summary>
            Represents a composite equivalency step that passes the execution to all user-supplied steps that can handle the
            current context.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.SelectedMemberInfo">
            <summary>
            Exposes information about an object's member
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelectedMemberInfo.Name">
            <summary>
            Gets the name of the current member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelectedMemberInfo.MemberType">
            <summary>
            Gets the type of this member.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelectedMemberInfo.DeclaringType">
            <summary>
            Gets the class that declares this member.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelectedMemberInfo.GetGetAccessModifier">
            <summary>
            Gets the access modifier for the getter of this member.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelectedMemberInfo.GetSetAccessModifier">
            <summary>
            Gets the access modifier for the setter of this member.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelectedMemberInfo.GetValue(System.Object,System.Object[])">
            <summary>
            Returns the member value of a specified object with optional index values for indexed properties or methods.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.AllPublicFieldsSelectionRule">
            <summary>
            Selection rule that adds all public fields of the subject.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.AllPublicFieldsSelectionRule.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.AllPublicPropertiesSelectionRule">
            <summary>
            Selection rule that adds all public properties of the subject.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.AllPublicPropertiesSelectionRule.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.ExcludeMemberByPathSelectionRule">
            <summary>
            Selection rule that removes a particular property from the structural comparison.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.ExcludeMemberByPredicateSelectionRule">
            <summary>
            Selection rule that removes a particular member from the structural comparison based on a predicate.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.ExcludeMemberByPredicateSelectionRule.ToString">
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.IncludeMemberByPathSelectionRule">
            <summary>
            Selection rule that includes a particular property in the structural comparison.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.IncludeMemberByPredicateSelectionRule">
            <summary>
            Selection rule that includes a particular member in the structural comparison.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.Selection.IncludeMemberByPredicateSelectionRule.ToString">
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.MemberPath">
            <summary>
            Encapsulates a dotted candidate to a (nested) member of a type.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.Selection.NestedSelectionContext">
            <summary>
            Represents a selection context of a nested property
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.Selection.NestedSelectionContext.CompileTimeType">
            <summary>
            Gets the compile-time type of the current object. If the current object is not the root object, then it returns the
            same <see cref="T:System.Type"/> as the <see cref="P:FluentAssertions.Equivalency.IMemberInfo.RuntimeType"/> property does.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.Selection.NestedSelectionContext.RuntimeType">
            <summary>
            Gets the run-time type of the current object.
            </summary>
        </member>
        <member name="T:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1">
            <summary>
                Represents the run-time behavior of a structural equivalency assertion.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.#ctor(FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
                Creates an instance of the equivalency assertions options based on defaults previously configured by the caller.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#SelectionRules">
            <summary>
                Gets an ordered collection of selection rules that define what members are included.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#MatchingRules">
            <summary>
                Gets an ordered collection of matching rules that determine which subject members are matched with which
                expectation members.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#UserEquivalencySteps">
            <summary>
                Gets an ordered collection of Equivalency steps how a subject is compared with the expectation.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#OrderingRules">
            <summary>
                Gets an ordered collection of rules that determine whether or not the order of collections is important. By
                default,
                ordering is irrelevant.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#IsRecursive">
            <summary>
                Gets value indicating whether the equality check will include nested collections and complex types.
            </summary>
        </member>
        <member name="P:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.FluentAssertions#Equivalency#IEquivalencyAssertionOptions#CyclicReferenceHandling">
            <summary>
                Gets value indicating how cyclic references should be handled. By default, it will throw an exception.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingAllDeclaredProperties">
            <summary>
                Causes inclusion of only public properties of the subject as far as they are defined on the declared type.
            </summary>
            <remarks>
                This clears all previously registered selection rules.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingAllRuntimeProperties">
            <summary>
                Causes inclusion of only public properties of the subject based on its run-time type rather than its declared type.
            </summary>
            <remarks>
                This clears all previously registered selection rules.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingFields">
            <summary>
                Instructs the comparison to include fields.
            </summary>
            <remarks>
                This is part of the default behavior.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingFields">
            <summary>
                Instructs the comparison to exclude fields.
            </summary>
            <remarks>
                This does not preclude use of `Including`.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingProperties">
            <summary>
                Instructs the comparison to include properties.
            </summary>
            <remarks>
                This is part of the default behavior.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingProperties">
            <summary>
                Instructs the comparison to exclude properties.
            </summary>
            <remarks>
                This does not preclude use of `Including`.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.RespectingRuntimeTypes">
            <summary>
                Instructs the comparison to respect the expectation's runtime type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.RespectingDeclaredTypes">
            <summary>
                Instructs the comparison to respect the expectation's declared type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Excluding(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
                Excludes a (nested) property based on a predicate from the structural equality check.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingMissingMembers">
            <summary>
                Tries to match the members of the subject with equally named members on the expectation. Ignores those
                members that don't exist on the expectation and previously registered matching rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ThrowingOnMissingMembers">
            <summary>
                Requires the expectation to have members which are equally named to members on the subject.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using``1(System.Action{FluentAssertions.Equivalency.IAssertionContext{``0}})">
            <summary></summary>
            <param name="action">
                The assertion to execute when the predicate is met.
            </param>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IncludingNestedObjects">
            <summary>
                Causes the structural equality check to include nested collections and complex types.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ExcludingNestedObjects">
            <summary>
                Causes the structural equality check to exclude nested collections and complex types.
            </summary>
            <remarks>
                Behaves similarly to the old property assertions API.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.IgnoringCyclicReferences">
            <summary>
                Causes the structural equality check to ignore any cyclic references.
            </summary>
            <remarks>
                By default, cyclic references within the object graph will cause an exception to be thrown.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.AllowingInfiniteRecursion">
            <summary>
                Disables limitations on recursion depth when the structural equality check is configured to include nested objects
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutSelectionRules">
            <summary>
                Clears all selection rules, including those that were added by default.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutMatchingRules">
            <summary>
                Clears all matching rules, including those that were added by default.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IMemberSelectionRule)">
            <summary>
                Adds a selection rule to the ones already added by default, and which is evaluated after all existing rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IMemberMatchingRule)">
            <summary>
                Adds a matching rule to the ones already added by default, and which is evaluated before all existing rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IAssertionRule)">
            <summary>
                Adds an assertion rule to the ones already added by default, and which is evaluated before all existing rules.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Using(FluentAssertions.Equivalency.IEquivalencyStep)">
            <summary>
                Adds an equivalency step rule to the ones already added by default, and which is evaluated before previous
                user-registered steps
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithStrictOrdering">
            <summary>
                Causes all collections to be compared in the order in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithStrictOrderingFor(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
                Causes the collection identified by the provided <paramref name="predicate" /> to be compared in the order
                in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutStrictOrderingFor(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
                Causes the collection identified by the provided <paramref name="predicate" /> to be compared ignoring the order
                in which the items appear in the expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingEnumsByName">
            <summary>
                Causes to compare Enum properties using the result of their ToString method.
            </summary>
            <remarks>
                By default, enums are compared by value.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingEnumsByValue">
            <summary>
                Causes to compare Enum members using their underlying value only.
            </summary>
            <remarks>
                This is the default.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingByMembers``1">
            <summary>
                Marks the <typeparamref name="T" /> as a type that should be compared by its members even though it may override
                the <see cref="M:System.Object.Equals(System.Object)" /> method.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ComparingByValue``1">
            <summary>
                Marks the <typeparamref name="T" /> as a value type which must be compared using its
                <see cref="M:System.Object.Equals(System.Object)" /> method, regardless of it overriding it or not.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithTracing(FluentAssertions.Equivalency.ITraceWriter)">
            <summary>
                Enables tracing the steps the equivalency validation followed to compare two graphs.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithAutoConversion">
            <summary>
                Instructs the equivalency comparison to try to convert the values of
                matching properties before running any of the other steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithAutoConversionFor(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
                Instructs the equivalency comparison to try to convert the value of
                a specific property on the expectation object before running any of the other steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.WithoutAutoConversionFor(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
                Instructs the equivalency comparison to prevent trying to convert the value of
                a specific property on the expectation object before running any of the other steps.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Restriction`1">
            <summary>
                Defines additional overrides when used with <see cref="!:EquivalencyAssertionOptions.When" />
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Restriction`1.WhenTypeIs``1">
            <summary>
                Allows overriding the way structural equality is applied to (nested) objects of type
                <typeparamref name="TMemberType" />
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1.Restriction`1.When(System.Linq.Expressions.Expression{System.Func{FluentAssertions.Equivalency.IMemberInfo,System.Boolean}})">
            <summary>
                Allows overriding the way structural equality is applied to particular members.
            </summary>
            <param name="predicate">
                A predicate based on the <see cref="T:FluentAssertions.Equivalency.IMemberInfo" /> of the subject that is used to identify the property for which
                the
                override applies.
            </param>
        </member>
        <member name="M:FluentAssertions.Equivalency.SimpleEqualityEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SimpleEqualityEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.StringEqualityEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.StringEqualityEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.StructuralEqualityEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.SubjectInfoExtensions.WhichSetterHas(FluentAssertions.Equivalency.IMemberInfo,FluentAssertions.Common.CSharpAccessModifier)">
            <summary>
            Checks if the subject info setter has the given access modifier.
            </summary>
            <param name="memberInfo">The subject info being checked.</param>
            <param name="accessModifier">The access modifier that the subject info setter should have.</param>
            <returns>True if the subject info setter has the given access modifier, false otherwise.</returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.SubjectInfoExtensions.WhichSetterDoesNotHave(FluentAssertions.Equivalency.IMemberInfo,FluentAssertions.Common.CSharpAccessModifier)">
            <summary>
            Checks if the subject info setter does not have the given access modifier.
            </summary>
            <param name="memberInfo">The subject info being checked.</param>
            <param name="accessModifier">The access modifier that the subject info setter should not have.</param>
            <returns>True if the subject info setter does not have the given access modifier, false otherwise.</returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.SubjectInfoExtensions.WhichGetterHas(FluentAssertions.Equivalency.IMemberInfo,FluentAssertions.Common.CSharpAccessModifier)">
            <summary>
            Checks if the subject info getter has the given access modifier.
            </summary>
            <param name="memberInfo">The subject info being checked.</param>
            <param name="accessModifier">The access modifier that the subject info getter should have.</param>
            <returns>True if the subject info getter has the given access modifier, false otherwise.</returns>
        </member>
        <member name="M:FluentAssertions.Equivalency.SubjectInfoExtensions.WhichGetterDoesNotHave(FluentAssertions.Equivalency.IMemberInfo,FluentAssertions.Common.CSharpAccessModifier)">
            <summary>
            Checks if the subject info getter does not have the given access modifier.
            </summary>
            <param name="memberInfo">The subject info being checked.</param>
            <param name="accessModifier">The access modifier that the subject info getter should not have.</param>
            <returns>True if the subject info getter does not have the given access modifier, false otherwise.</returns>
        </member>
        <member name="T:FluentAssertions.Equivalency.TryConversionStep">
            <summary>
            Attempts to convert the subject's property value to the expected type.
            </summary>
            <remarks>
            Whether or not the conversion is attempted depends on the <see cref="T:FluentAssertions.Equivalency.ConversionSelector"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Equivalency.TryConversionStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.TryConversionStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.ValueTypeEquivalencyStep">
            <summary>
            Ensures that types that are marked as value types are treated as such.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ValueTypeEquivalencyStep.CanHandle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Gets a value indicating whether this step can handle the current subject and/or expectation.
            </summary>
        </member>
        <member name="M:FluentAssertions.Equivalency.ValueTypeEquivalencyStep.Handle(FluentAssertions.Equivalency.IEquivalencyValidationContext,FluentAssertions.Equivalency.IEquivalencyValidator,FluentAssertions.Equivalency.IEquivalencyAssertionOptions)">
            <summary>
            Applies a step as part of the task to compare two objects for structural equality.
            </summary>
            <value>
            Should return <c>true</c> if the subject matches the expectation or if no additional assertions
            have to be executed. Should return <c>false</c> otherwise.
            </value>
            <remarks>
            May throw when preconditions are not met or if it detects mismatching data.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Equivalency.ITraceWriter">
            <summary>
            Defines the contract for an object that is used by Fluent Assertions to provide tracing in the equivalency API
            </summary>
        </member>
        <member name="T:FluentAssertions.EventRaisingExtensions">
            <summary>
              Provides extension methods for monitoring and querying events.
            </summary>
        </member>
        <member name="M:FluentAssertions.EventRaisingExtensions.WithSender(FluentAssertions.Events.IEventRecorder,System.Object)">
            <summary>
            Asserts that all occurrences of the event originated from the <param name="expectedSender"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.EventRaisingExtensions.WithArgs``1(FluentAssertions.Events.IEventRecorder,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Asserts that at least one occurrence of the event had at least one of the arguments matching a predicate.
            </summary>
        </member>
        <member name="M:FluentAssertions.EventRaisingExtensions.WithArgs``1(FluentAssertions.Events.IEventRecorder,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}}[])">
            <summary>
            Asserts that at least one occurrence of the event had arguments matching all predicates.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.EventAssertions`1">
            <summary>
            Provides convenient assertion methods on a <see cref="T:FluentAssertions.Events.IMonitor`1"/> that can be
            used to assert that certain events have been raised.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventAssertions`1.Raise(System.String,System.String,System.Object[])">
            <summary>
            Asserts that an object has raised a particular event at least once.
            </summary>
            <param name="eventSource">The object exposing the event.</param>
            <param name="eventName">
            The name of the event that should have been raised.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
            <remarks>
            You must call <see cref="M:FluentAssertions.AssertionExtensions.Monitor``1(``0,System.Func{System.DateTime})"/> on the same object prior to this call so that Fluent Assertions can
            subscribe for the events of the object.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Events.EventAssertions`1.NotRaise(System.String,System.String,System.Object[])">
            <summary>
            Asserts that an object has not raised a particular event.
            </summary>
            <param name="eventSource">The object exposing the event.</param>
            <param name="eventName">
            The name of the event that should not be raised.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
            <remarks>
            You must call <see cref="!:MonitorEvents"/> on the same object prior to this call so that Fluent Assertions can
            subscribe for the events of the object.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Events.EventAssertions`1.RaisePropertyChangeFor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Object[])">
            <summary>
            Asserts that an object has raised the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for a particular property.
            </summary>
            <param name="eventSource">The object exposing the event.</param>
            <param name="propertyExpression">
            A lambda expression referring to the property for which the property changed event should have been raised, or
            <c>null</c> to refer to all properties.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
            <remarks>
            You must call <see cref="M:FluentAssertions.AssertionExtensions.Monitor``1(``0,System.Func{System.DateTime})"/> on the same object prior to this call so that Fluent Assertions can
            subscribe for the events of the object.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Events.EventAssertions`1.NotRaisePropertyChangeFor(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.Object[])">
            <summary>
            Asserts that an object has not raised the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for a particular property.
            </summary>
            <param name="eventSource">The object exposing the event.</param>
            <param name="propertyExpression">
            A lambda expression referring to the property for which the property changed event should have been raised.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
            <remarks>
            You must call <see cref="M:FluentAssertions.AssertionExtensions.Monitor``1(``0,System.Func{System.DateTime})"/> on the same object prior to this call so that Fluent Assertions can
            subscribe for the events of the object.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Events.EventHandlerFactory">
            <summary>
              Static methods that aid in generic event subscription
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.GenerateHandler(System.Type,FluentAssertions.Events.IEventRecorder)">
            <summary>
              Generates an eventhandler for an event of type eventSignature that calls RegisterEvent on recorder
              when invoked.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.GetDelegateReturnType(System.Type)">
            <summary>
              Finds the Return Type of a Delegate.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.GetDelegateParameterTypes(System.Type)">
            <summary>
              Returns an Array of Types that make up a delegate's parameter signature.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.AppendParameterListThisReference(System.Type[])">
            <summary>
              Returns an array of types appended with an EventRecorder reference at the beginning.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.TypeIsDelegate(System.Type)">
            <summary>
              Returns T/F Dependent on a Type Being a Delegate.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventHandlerFactory.DelegateInvokeMethod(System.Type)">
            <summary>
              Returns the MethodInfo for the Delegate's "Invoke" Method.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.EventMonitor`1">
            <summary>
            Tracks the events an object raises.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.EventRecorder">
            <summary>
              Records activity for a single event.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.#ctor(System.Object,System.String,System.Func{System.DateTime})">
            <summary>
            </summary>
            <param name = "eventRaiser">The object events are recorded from</param>
            <param name = "eventName">The name of the event that's recorded</param>
            <param name="utcNow">A delegate to get the current date and time in UTC format.</param>
        </member>
        <member name="P:FluentAssertions.Events.EventRecorder.EventObject">
            <summary>
              The object events are recorded from
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.EventRecorder.EventName">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.GetEnumerator">
            <summary>
              Enumerate raised events
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.System#Collections#IEnumerable#GetEnumerator">
            <summary>
              Enumerate raised events
            </summary>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.RecordEvent(System.Object[])">
            <summary>
              Called by the auto-generated IL, to record information about a raised event.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.EventRecorder.Reset">
            <summary>
              Resets recorder to clear records of events raised so far.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.IEventRecorder">
            <summary>
              Records raised events for one event on one object
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.IEventRecorder.RecordEvent(System.Object[])">
            <summary>
              Store information about a raised event
            </summary>
            <param name = "parameters">Parameters the event was raised with</param>
        </member>
        <member name="M:FluentAssertions.Events.IEventRecorder.Reset">
            <summary>
            Resets the event recorder, removing any events recorded thus far.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IEventRecorder.EventObject">
            <summary>
              The object events are recorded from
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IEventRecorder.EventName">
            <summary>
              The name of the event that's recorded
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IEventRecorder.EventHandlerType">
            <summary>
            The type of the event handler identified by <see cref="P:FluentAssertions.Events.IEventRecorder.EventName"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.IMonitor`1">
            <summary>
            Monitors events on a given source
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IMonitor`1.Subject">
            <summary>
            Gets the object that is being monitored or <c>null</c> if the object has been GCed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.IMonitor`1.Clear">
            <summary>
            Clears all recorded events from the monitor and continues monitoring.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.IMonitor`1.Should">
            <summary>
            Provides access to several assertion methods.
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.IMonitor`1.GetEventRecorder(System.String)">
            <summary>
            Gets an object that tracks the occurrences of a particular <paramref name="eventName"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IMonitor`1.MonitoredEvents">
            <summary>
            Gets the metadata of all the events that are currently being monitored.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.IMonitor`1.OccurredEvents">
            <summary>
            Gets a collection of all events that have occurred since the monitor was created or
            <see cref="M:FluentAssertions.Events.IMonitor`1.Clear"/> was called.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.OccurredEvent">
            <summary>
            Represents an occurrence of a particular event.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.OccurredEvent.EventName">
            <summary>
            The name of the event as defined on the monitored object.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.OccurredEvent.Parameters">
            <summary>
            The parameters that were passed to the event handler.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.OccurredEvent.TimestampUtc">
            <summary>
            The exact date and time of the occurrence in <see cref="F:System.DateTimeKind.Local"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.EventMetadata">
            <summary>
            Provides the metadata of a monitored event.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.EventMetadata.EventName">
            <summary>
            The name of the event member on the monitored object
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.EventMetadata.HandlerType">
            <summary>
            The type of the event handler and event args.
            </summary>
        </member>
        <member name="T:FluentAssertions.Events.RecordedEvent">
            <summary>
            This class is used to store data about an intercepted event
            </summary>
        </member>
        <member name="M:FluentAssertions.Events.RecordedEvent.#ctor(System.DateTime,System.Object,System.Object[])">
            <summary>
            Default constructor stores the parameters the event was raised with
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.RecordedEvent.TimestampUtc">
            <summary>
            The exact data and time in UTC format at which the event occurred.
            </summary>
        </member>
        <member name="P:FluentAssertions.Events.RecordedEvent.Parameters">
            <summary>
            Parameters for the event
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.AssertionFailedException">
            <summary>
            Represents the default exception in case no test framework is configured.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.AssertionScope">
            <summary>
            Represents an implicit or explicit scope within which multiple assertions can be collected.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor">
            <summary>
            Starts an unnamed scope within which multiple assertions can be executed
            and which will not throw until the scope is disposed.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor(System.String)">
            <summary>
            Starts a named scope within which multiple assertions can be executed and which will not throw until the scope is disposed.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.Context">
            <summary>
            Gets or sets the context of the current assertion scope, e.g. the path of the object graph
            that is being asserted on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.#ctor(FluentAssertions.Execution.AssertionScope,System.Boolean)">
            <summary>
            Creates a nested scope used during chaining.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.Current">
            <summary>
            Gets the current thread-specific assertion scope.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.UsingLineBreaks">
            <summary>
            Indicates that every argument passed into <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> is displayed on a separate line.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.AssertionScope.Succeeded">
            <summary>
            Gets a value indicating whether or not the last assertion executed through this scope succeeded.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])">
            <summary>
            Specify the reason why you expect the condition to be <c>true</c>.
            </summary>
            <param name="because">
            A formatted phrase compatible with <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why
            the condition should be satisfied. If the phrase does not start with the word <i>because</i>,
            it is prepended to the message. If the format of <paramref name="because"/> or
            <paramref name="becauseArgs"/> is not compatible with <see cref="M:System.String.Format(System.String,System.Object[])"/>,
            then a warning message is returned instead.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])">
            <summary>
            Sets the expectation part of the failure message when the assertion is not met.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a few
            specialized placeholders as well. For instance, {reason} will be replaced with the reason of the assertion as passed
            to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>. Other named placeholders will be replaced with the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data
            passed through <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>. Finally, a description of the
            current subject can be passed through the {context:description} placeholder. This is used in the message if no
            explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor.
            Note that only 10 <paramref name="args"/> are supported in combination with a {reason}.
            If an expectation was set through a prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>, then the failure message is appended to that
            expectation.
            </remarks>
             <param name="expectation">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Given``1(System.Func{``0})">
            <summary>
            Allows to safely select the subject for successive assertions, even when the prior assertion has failed.
            </summary>
            <paramref name="selector">
            Selector which result is passed to successive calls to <see cref="M:FluentAssertions.Execution.AssertionScope.ForCondition(System.Boolean)"/>.
            </paramref>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.ForCondition(System.Boolean)">
            <summary>
            Specify the condition that must be satisfied.
            </summary>
            <param name="condition">
            If <c>true</c> the assertion will be treated as successful and no exceptions will be thrown.
            </param>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a
            prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a few
            specialized placeholders as well. For instance, {reason} will be replaced with the reason of the assertion as passed
            to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>. Other named placeholders will be replaced with
            the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data passed through
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>. Finally, a description of the
            current subject can be passed through the {context:description} placeholder. This is used in the message if no
            explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor.
            Note that only 10 <paramref name="args"/> are supported in combination with a {reason}.
            If an expectation was set through a prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>,
            then the failure message is appended to that expectation.
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.AddPreFormattedFailure(System.String)">
            <summary>
            Adds a pre-formatted failure message to the current scope.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)">
            <summary>
            Adds some information to the assertion scope that will be included in the message
            that is emitted if an assertion fails.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Discard">
            <summary>
            Discards and returns the failures that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Get``1(System.String)">
            <summary>
            Gets data associated with the current scope and identified by <paramref name="key"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.AssertionScope.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.CollectingAssertionStrategy.FailureMessages">
            <summary>
            Returns the messages for the assertion failures that happened until now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.CollectingAssertionStrategy.DiscardFailures">
            <summary>
            Discards and returns the failure messages that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.CollectingAssertionStrategy.ThrowIfAny(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Will throw a combined exception for any failures have been collected since <see cref="!:StartCollecting"/> was called.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.CollectingAssertionStrategy.HandleFailure(System.String)">
            <summary>
            Instructs the strategy to handle a assertion failure.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ContextDataItems">
            <summary>
            Represents a collection of data items that are associated with an <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.Continuation">
            <summary>
            Enables chaining multiple assertions on an <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.Continuation.Then">
            <summary>
            Continuous the assertion chain if the previous assertion was successful.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.Continuation.op_Implicit(FluentAssertions.Execution.Continuation)~System.Boolean">
            <summary>
            Provides back-wards compatibility for code that expects <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> to return a boolean.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ContinuationOfGiven`1">
            <summary>
            Enables chaining multiple assertions from a <see cref="M:FluentAssertions.Execution.AssertionScope.Given``1(System.Func{``0})"/> call.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.ContinuationOfGiven`1.Then">
            <summary>
            Continuous the assertion chain if the previous assertion was successful.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.ContinuationOfGiven`1.op_Implicit(FluentAssertions.Execution.ContinuationOfGiven{`0})~System.Boolean">
            <summary>
            Provides back-wards compatibility for code that expects <see cref="M:FluentAssertions.Execution.AssertionScope.FailWith(System.String,System.Object[])"/> to return a boolean.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.DefaultAssertionStrategy.FailureMessages">
            <summary>
            Returns the messages for the assertion failures that happened until now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.DefaultAssertionStrategy.HandleFailure(System.String)">
            <summary>
            Instructs the strategy to handle a assertion failure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.DefaultAssertionStrategy.DiscardFailures">
            <summary>
            Discards and returns the failure messages that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.DefaultAssertionStrategy.ThrowIfAny(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Will throw a combined exception for any failures have been collected since <see cref="!:StartCollecting"/> was called.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.Execute">
            <summary>
            Helper class for verifying a condition and/or throwing a test harness specific exception representing an assertion failure.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.Execute.Assertion">
            <summary>
            Gets an object that wraps and executes a conditional or unconditional assertion.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.FallbackTestFramework">
            <summary>
            Throws a generic exception in case no other test harness is detected.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.FallbackTestFramework.IsAvailable">
            <summary>
            Gets a value indicating whether the corresponding test framework is currently available.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.FallbackTestFramework.Throw(System.String)">
            <summary>
            Throws a framework-specific exception to indicate a failing unit test.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.GallioTestFramework.Throw(System.String)">
            <summary>
            Throws a framework-specific exception to indicate a failing unit test.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.GallioTestFramework.IsAvailable">
            <summary>
            Gets a value indicating whether the corresponding test framework is currently available.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.GivenSelector`1">
            <summary>
            Represents a chaining object returned from <see cref="M:FluentAssertions.Execution.AssertionScope.Given``1(System.Func{``0})"/> to continue the assertion using
            an object returned by a selector.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.ForCondition(System.Func{`0,System.Boolean})">
            <summary>
            Specify the condition that must be satisfied upon the subject selected through a prior selector.
            </summary>
            <param name="predicate">
            If <c>true</c> the assertion will be treated as successful and no exceptions will be thrown.
            </param>
            <remarks>
            The condition will not be evaluated if the prior assertion failed,
            nor will <see cref="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])"/> throw any exceptions.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.Given``1(System.Func{`0,``0})">
            <summary>
            Allows to safely refine the subject for successive assertions, even when the prior assertion has failed.
            </summary>
            <paramref name="selector">
            Selector which result is passed to successive calls to <see cref="M:FluentAssertions.Execution.GivenSelector`1.ForCondition(System.Func{`0,System.Boolean})"/>.
            </paramref>
            <remarks>
            The selector will not be invoked if the prior assertion failed,
            nor will <see cref="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])"/> throw any exceptions.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String)">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a
            prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>.
            </summary>
            <remarks>
            If an expectation was set through a prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>,
            then the failure message is appended to that expectation.
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Func{`0,System.Object}[])">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a
            prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain a few
            specialized placeholders as well. For instance, {reason} will be replaced with the reason of the assertion as passed
            to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>. Other named placeholders will be replaced with
            the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data passed through
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>. Finally, a description of the current subject
            can be passed through the {context:description} placeholder. This is used in the message if no explicit context
            is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor.
            Note that only 10 <paramref name="args"/> are supported in combination with a {reason}.
            If an expectation was set through a prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>,
            then the failure message is appended to that expectation.
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="M:FluentAssertions.Execution.GivenSelector`1.FailWith(System.String,System.Object[])">
            <summary>
            Sets the failure message when the assertion is not met, or completes the failure message set to a
            prior call to <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>.
            </summary>
            <remarks>
            In addition to the numbered <see cref="M:System.String.Format(System.String,System.Object[])"/>-style placeholders, messages may contain
            a few specialized placeholders as well. For instance, {reason} will be replaced with the reason of the assertion as
            passed to <see cref="M:FluentAssertions.Execution.AssertionScope.BecauseOf(System.String,System.Object[])"/>. Other named placeholders will be
            replaced with the <see cref="P:FluentAssertions.Execution.AssertionScope.Current"/> scope data passed through
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddNonReportable(System.String,System.Object)"/> and
            <see cref="M:FluentAssertions.Execution.AssertionScope.AddReportable(System.String,System.String)"/>. Finally, a description of the
            current subject can be passed through the {context:description} placeholder. This is used in the message if no
            explicit context is specified through the <see cref="T:FluentAssertions.Execution.AssertionScope"/> constructor.
            Note that only 10 <paramref name="args"/> are supported in combination with a {reason}.
            If an expectation was set through a prior call to
            <see cref="M:FluentAssertions.Execution.AssertionScope.WithExpectation(System.String,System.Object[])"/>, then the failure message is appended
            to that expectation.
            </remarks>
            <param name="message">The format string that represents the failure message.</param>
            <param name="args">Optional arguments to any numbered placeholders.</param>
        </member>
        <member name="T:FluentAssertions.Execution.IAssertionStrategy">
            <summary>
            Defines a strategy for handling failures in a <see cref="T:FluentAssertions.Execution.AssertionScope"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.IAssertionStrategy.FailureMessages">
            <summary>
            Returns the messages for the assertion failures that happened until now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionStrategy.HandleFailure(System.String)">
            <summary>
            Instructs the strategy to handle a assertion failure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionStrategy.DiscardFailures">
            <summary>
            Discards and returns the failure messages that happened up to now.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.IAssertionStrategy.ThrowIfAny(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Will throw a combined exception for any failures have been collected since <see cref="!:StartCollecting"/> was called.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.ICloneable2">
            <summary>
            Custom version of ICloneable that works on all frameworks.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.ICloneable2.Clone">
             <summary>
             Creates a new object that is a copy of the current instance.
             </summary>
            
             <returns>
             A new object that is a copy of this instance.
             </returns>
        </member>
        <member name="T:FluentAssertions.Execution.ITestFramework">
            <summary>
            Represents an abstraction of a particular test framework such as MSTest, nUnit, etc.
            </summary>
        </member>
        <member name="P:FluentAssertions.Execution.ITestFramework.IsAvailable">
            <summary>
            Gets a value indicating whether the corresponding test framework is currently available.
            </summary>
        </member>
        <member name="M:FluentAssertions.Execution.ITestFramework.Throw(System.String)">
            <summary>
            Throws a framework-specific exception to indicate a failing unit test.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.MessageBuilder">
            <summary>
            Encapsulates expanding the various placeholders supported in a failure message.
            </summary>
        </member>
        <member name="T:FluentAssertions.Execution.Reportability">
            <summary>
            Determines whether data associated with an <see cref="T:FluentAssertions.Execution.AssertionScope"/> should be included in the assertion failure.
            </summary>
        </member>
        <member name="T:FluentAssertions.Extensions.FluentDateTimeExtensions">
            <summary>
            Extension methods on <see cref="T:System.Int32"/> to allow for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </summary>
            <example>
            Instead of<br />
            <br />
            new DateTime(2011, 3, 10)<br />
            <br />
            you can write 3.March(2011)<br />
            <br />
            Or even<br />
            <br />
            3.March(2011).At(09, 30)
            </example>
            <seealso cref="T:FluentAssertions.Extensions.FluentTimeSpanExtensions"/>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.January(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month January.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.February(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month February.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.March(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month March.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.April(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month April.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.May(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month May.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.June(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month June.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.July(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month July.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.August(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month August.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.September(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month September.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.October(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month October.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.November(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month November.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.December(System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="day"/> and <paramref name="year"/>
            in the month December.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.At(System.DateTime,System.TimeSpan)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="date"/> and <paramref name="time"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.At(System.DateTime,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="date"/> and time with the specified
            <paramref name="hours"/>, <paramref name="minutes"/> and optionally <paramref name="seconds"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.At(System.DateTimeOffset,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new <see cref="T:System.DateTimeOffset"/> value for the specified <paramref name="date"/> and time with the specified
            <paramref name="hours"/>, <paramref name="minutes"/> and optionally <paramref name="seconds"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AsUtc(System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="dateTime"/> and time with
            the kind set to <see cref="F:System.DateTimeKind.Utc"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AsLocal(System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value for the specified <paramref name="dateTime"/> and time with
            the kind set to <see cref="F:System.DateTimeKind.Local"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.Before(System.TimeSpan,System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value that is the current <see cref="T:System.TimeSpan"/> before the
            specified <paramref name="sourceDateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.After(System.TimeSpan,System.DateTime)">
            <summary>
            Returns a new <see cref="T:System.DateTime"/> value that is the current <see cref="T:System.TimeSpan"/> after the
            specified <paramref name="sourceDateTime"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.Nanosecond(System.DateTime)">
            <summary>
            Gets the nanoseconds component of the date represented by the current <see cref="T:System.DateTime" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AddNanoseconds(System.DateTime,System.Int64)">
            <summary>
            Returns a new <see cref="T:System.DateTime" /> that adds the specified number of nanoseconds to the value of this instance.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.Microsecond(System.DateTime)">
            <summary>
            Gets the microseconds component of the date represented by the current <see cref="T:System.DateTime" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentDateTimeExtensions.AddMicroseconds(System.DateTime,System.Int64)">
            <summary>
            Returns a new <see cref="T:System.DateTime" /> that adds the specified number of microseconds to the value of this instance.
            </summary>
        </member>
        <member name="T:FluentAssertions.Extensions.FluentTimeSpanExtensions">
            <summary>
            Extension methods on <see cref="T:System.Int32"/> to allow for a more fluent way of specifying a <see cref="T:System.TimeSpan"/>.
            </summary>
            <example>
            Instead of<br />
            <br />
            TimeSpan.FromHours(12)<br />
            <br />
            you can write<br />
            <br />
            12.Hours()<br />
            <br />
            Or even<br />
            <br />
            12.Hours().And(30.Minutes()).
            </example>
            <seealso cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
        </member>
        <member name="F:FluentAssertions.Extensions.FluentTimeSpanExtensions.TicksPerMicrosecond">
            <summary>
            Represents the number of ticks that are in 1 microsecond.
            </summary>
        </member>
        <member name="F:FluentAssertions.Extensions.FluentTimeSpanExtensions.TicksPerNanosecond">
            <summary>
            Represents the number of ticks that are in 1 nanosecond.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Ticks(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of ticks.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Ticks(System.Int64)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of ticks.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Nanoseconds(System.TimeSpan)">
            <summary>
            Gets the nanoseconds component of the time interval represented by the current <see cref="T:System.TimeSpan" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Nanoseconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of nanoseconds.
            </summary>
            <remarks>
            .NET's smallest resolutions is 100 nanoseconds. Any nanoseconds passed in
            lower than .NET's resolution will be rounded using the default rounding
            algorithm in Math.Round().
            </remarks>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Nanoseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of nanoseconds.
            </summary>
            <remarks>
            .NET's smallest resolutions is 100 nanoseconds. Any nanoseconds passed in
            lower than .NET's resolution will be rounded using the default rounding
            algorithm in Math.Round().
            </remarks>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.TotalNanoseconds(System.TimeSpan)">
            <summary>
            Gets the value of the current <see cref="T:System.TimeSpan" /> structure expressed in whole and fractional nanoseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Microseconds(System.TimeSpan)">
            <summary>
            Gets the microseconds component of the time interval represented by the current <see cref="T:System.TimeSpan" /> structure.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Microseconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of microseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Microseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of microseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.TotalMicroseconds(System.TimeSpan)">
            <summary>
            Gets the value of the current <see cref="T:System.TimeSpan" /> structure expressed in whole and fractional microseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Milliseconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of milliseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Milliseconds(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of milliseconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Seconds(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of seconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Seconds(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of seconds.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Seconds(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of seconds, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Minutes(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of minutes.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Minutes(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of minutes.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Minutes(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of minutes, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Hours(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of hours.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Hours(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of hours.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Hours(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of hours, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Days(System.Int32)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of days.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Days(System.Double)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of days.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.Days(System.Int32,System.TimeSpan)">
            <summary>
            Returns a <see cref="T:System.TimeSpan" /> based on a number of days, and add the specified
            <paramref name="offset"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Extensions.FluentTimeSpanExtensions.And(System.TimeSpan,System.TimeSpan)">
            <summary>
            Convenience method for chaining multiple calls to the methods provided by this class.
            </summary>
            <example>
            23.Hours().And(59.Minutes())
            </example>
        </member>
        <member name="M:FluentAssertions.Formatting.AggregateExceptionValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.AggregateExceptionValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="context"> </param>
            <param name="formatChild"></param>
            <param name="processedObjects">
            A collection of objects that
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:FluentAssertions.Formatting.AttributeBasedFormatter">
            <summary>
            Specialized value formatter that looks for static methods in the caller's assembly marked with the
            <see cref="T:FluentAssertions.Formatting.ValueFormatterAttribute"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.AttributeBasedFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.AttributeBasedFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.ByteValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.ByteValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks"> </param>
            <param name="processedObjects">
            A collection of objects that
            </param>
            <param name="nestedPropertyLevel">
            The level of nesting for the supplied value. This is used for indenting the format string for objects that have
            no <see cref="M:System.Object.ToString"/> override.
            </param>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DateTimeOffsetValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DateTimeOffsetValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.DecimalValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DecimalValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.DefaultValueFormatter.CanHandle(System.Object)">
            <summary>
              Determines whether this instance can handle the specified value.
            </summary>
            <param name = "value">The value.</param>
            <returns>
              <c>true</c> if this instance can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DefaultValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.DoubleValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.DoubleValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.EnumerableValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.EnumerableValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.ExceptionValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.ExceptionValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.ExpressionValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.ExpressionValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="T:FluentAssertions.Formatting.Formatter">
            <summary>
            Provides services for formatting an object being used in an assertion in a human readable format.
            </summary>
        </member>
        <member name="F:FluentAssertions.Formatting.Formatter.isRentry">
            <summary>
            Is used to detect recursive calls by <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> implementations.
            </summary>
        </member>
        <member name="P:FluentAssertions.Formatting.Formatter.Formatters">
            <summary>
            A list of objects responsible for formatting the objects represented by placeholders.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.ToString(System.Object,System.Boolean)">
            <summary>
            Returns a human-readable representation of a particular object.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <param name="useLineBreaks">
            Indicates whether the formatter should use line breaks when the specific <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> supports it.
            </param>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.RemoveFormatter(FluentAssertions.Formatting.IValueFormatter)">
            <summary>
            Removes a custom formatter that was previously added though <see cref="M:FluentAssertions.Formatting.Formatter.AddFormatter(FluentAssertions.Formatting.IValueFormatter)"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.Formatter.AddFormatter(FluentAssertions.Formatting.IValueFormatter)">
            <summary>
            Ensures a custom formatter is included in the chain, just before the default formatter is executed.
            </summary>
        </member>
        <member name="T:FluentAssertions.Formatting.Formatter.ObjectGraph">
            <summary>
            Tracks the objects that were formatted as well as the path in the object graph of
            that object.
            </summary>
            <remarks>
            Is used to detect the maximum recursion depth as well as cyclic references in the graph.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.GuidValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.GuidValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.Int16ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.Int16ValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.Int32ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.Int32ValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.Int64ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.Int64ValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="T:FluentAssertions.Formatting.IValueFormatter">
            <summary>
            Represents a strategy for formatting an arbitrary value into a human-readable string representation.
            </summary>
            <remarks>
            Add custom formatters using <see cref="M:FluentAssertions.Formatting.Formatter.AddFormatter(FluentAssertions.Formatting.IValueFormatter)"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Formatting.IValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.IValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <summary>
            Returns a human-readable representation of <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to format.</param>
            <param name="context">
                Contains additional information about the formatting task.
            </param>
            <param name="formatChild">
                Allows the formatter to recursively format any child objects.
            </param>
            <remarks>
            DO NOT CALL <see cref="M:FluentAssertions.Formatting.Formatter.ToString(System.Object,System.Boolean)"/> directly, but use <paramref name="formatChild"/>
            instead. This will ensure cyclic dependencies are properly detected.
            </remarks>
        </member>
        <member name="T:FluentAssertions.Formatting.FormattingContext">
            <summary>
            Provides information about the current formatting action.
            </summary>
        </member>
        <member name="T:FluentAssertions.Formatting.FormatChild">
            <summary>
            Represents a method that can be used to format child values from inside a <see cref="T:FluentAssertions.Formatting.IValueFormatter"/>.
            </summary>
            <param name="childPath">
            Represents the path from the current location to the child value.
            </param>
            <param name="value">
            The child value to run through the configured <see cref="T:FluentAssertions.Formatting.IValueFormatter"/>s.
            </param>
        </member>
        <member name="M:FluentAssertions.Formatting.NullValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.NullValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.PropertyInfoFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.PropertyInfoFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.SByteValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.SByteValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.SingleValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.SingleValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.StringValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.StringValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="T:FluentAssertions.Formatting.TaskFormatter">
            <summary>
            Provides a human readable version of a generic or non-generic <see cref="T:System.Threading.Tasks.Task"/>
            including its state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.TimeSpanValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.TimeSpanValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.UInt16ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.UInt16ValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.UInt32ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.UInt32ValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.UInt64ValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.UInt64ValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="T:FluentAssertions.Formatting.ValueFormatterAttribute">
            <summary>
            Marks a static method as a kind of <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> for a particular type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Formatting.XAttributeValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.XAttributeValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.XDocumentValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="M:FluentAssertions.Formatting.XElementValueFormatter.CanHandle(System.Object)">
            <summary>
            Indicates whether the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified <paramref name="value"/>.
            </summary>
            <param name="value">The value for which to create a <see cref="T:System.String"/>.</param>
            <returns>
            <c>true</c> if the current <see cref="T:FluentAssertions.Formatting.IValueFormatter"/> can handle the specified value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:FluentAssertions.Formatting.XElementValueFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="T:FluentAssertions.NumericAssertionsExtensions">
            <summary>
            Contains a number of extension methods for floating point <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.SByte},System.SByte,System.Byte,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Byte},System.Byte,System.Byte,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int16},System.Int16,System.UInt16,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt16},System.UInt16,System.UInt16,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int32},System.Int32,System.UInt32,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt32},System.UInt32,System.UInt32,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int64},System.Int64,System.UInt64,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt64},System.UInt64,System.UInt64,System.String,System.Object[])">
            <summary>
            Asserts an integral value is close to another value within a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="nearbyValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.SByte},System.SByte,System.Byte,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Byte},System.Byte,System.Byte,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int16},System.Int16,System.UInt16,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt16},System.UInt16,System.UInt16,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int32},System.Int32,System.UInt32,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt32},System.UInt32,System.UInt32,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.Int64},System.Int64,System.UInt64,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeCloseTo(FluentAssertions.Numeric.NumericAssertions{System.UInt64},System.UInt64,System.UInt64,System.String,System.Object[])">
            <summary>
            Asserts an integral value is not within another value by a specified value.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="distantValue">
            The nearby value to compare the actual value with.
            </param>
            <param name="delta">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.BeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value approximates another value as close as possible.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="expectedValue">
            The expected value to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Single},System.Single,System.Single,System.String,System.Object[])">
            <summary>
            Asserts a floating point value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Double},System.Double,System.Double,System.String,System.Object[])">
            <summary>
            Asserts a double value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NullableNumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.NumericAssertionsExtensions.NotBeApproximately(FluentAssertions.Numeric.NumericAssertions{System.Decimal},System.Decimal,System.Decimal,System.String,System.Object[])">
            <summary>
            Asserts a decimal value does not approximate another value by a given amount.
            </summary>
            <param name="parent">The <see cref="T:FluentAssertions.Numeric.NumericAssertions`1"/> object that is being extended.</param>
            <param name="unexpectedValue">
            The unexpected value to compare the actual value with.
            </param>
            <param name="precision">
            The minimum exclusive amount of which the two values should differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Numeric.ComparableTypeAssertions`1">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.IComparable`1"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.Be(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is considered equal to another object according to the implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeEquivalentTo``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="!:IEnumerable&lt;T&gt;"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeEquivalentTo``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="!:IEnumerable&lt;T&gt;"/> and all
            items in the collection are structurally equal.
            </remarks>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.NotBe(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is not equal to another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeLessThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is less than another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeLessOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is less than or equal to another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeGreaterThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is greater than another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeGreaterOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the subject is greater than or equal to another object according to its implementation of <see cref="T:System.IComparable`1"/>.
            </summary>
            <param name="expected">
            The object to pass to the subject's <see cref="M:System.IComparable`1.CompareTo(`0)"/> method.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.BeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value.
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.ComparableTypeAssertions`1.NotBeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is not within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value.
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="P:FluentAssertions.Numeric.ComparableTypeAssertions`1.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`1.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`1.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`1.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NullableNumericAssertions`1.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable numeric value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="T:FluentAssertions.Numeric.NumericAssertions`1">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.IComparable"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.Be(`0,System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is exactly the same as the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.Be(System.Nullable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is exactly the same as the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.NotBe(`0,System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is not the same as the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.NotBe(System.Nullable{`0},System.String,System.Object[])">
            <summary>
            Asserts that the integral number value is not the same as the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BePositive(System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is greater than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeNegative(System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is less than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeLessThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is less than the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeLessOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is less than or equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeGreaterThan(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is greater than the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeGreaterOrEqualTo(`0,System.String,System.Object[])">
            <summary>
            Asserts that the numeric value is greater than or equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The value to compare the current numeric value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value.
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.NotBeInRange(`0,`0,System.String,System.Object[])">
            <summary>
            Asserts that a value is not within a range.
            </summary>
            <remarks>
            Where the range is continuous or incremental depends on the actual type of the value.
            </remarks>
            <param name="minimumValue">
            The minimum valid value of the range.
            </param>
            <param name="maximumValue">
            The maximum valid value of the range.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeOneOf(`0[])">
            <summary>
            Asserts that a value is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeOneOf(System.Collections.Generic.IEnumerable{`0},System.String,System.Object[])">
            <summary>
            Asserts that a value is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.BeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is of the specified type <paramref name="expectedType"/>.
            </summary>
            <param name="expectedType">
            The type that the subject is supposed to be of.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Numeric.NumericAssertions`1.NotBeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is not of the specified type <paramref name="expectedType"/>.
            </summary>
            <param name="expectedType">
            The type that the subject is not supposed to be of.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeBinarySerializable(FluentAssertions.Primitives.ObjectAssertions,System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the binary serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeBinarySerializable``1(FluentAssertions.Primitives.ObjectAssertions,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the binary serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeDataContractSerializable(FluentAssertions.Primitives.ObjectAssertions,System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the data contract serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeDataContractSerializable``1(FluentAssertions.Primitives.ObjectAssertions,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the data contract serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.ObjectAssertionsExtensions.BeXmlSerializable(FluentAssertions.Primitives.ObjectAssertions,System.String,System.Object[])">
            <summary>
            Asserts that an object can be serialized and deserialized using the XML serializer and that it stills retains
            the values of all members.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.BooleanAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Boolean"/> is in the expected state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.BooleanAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions.BeFalse(System.String,System.Object[])">
            <summary>
            Asserts that the value is <c>false</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions.BeTrue(System.String,System.Object[])">
            <summary>
            Asserts that the value is <c>true</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.BooleanAssertions.Be(System.Boolean,System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.DateTime"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="P:FluentAssertions.Primitives.DateTimeAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.Be(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> is exactly equal to the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotBe(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> or <see cref="T:System.DateTime"/> is not equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeCloseTo(System.DateTime,System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is within the specified number of milliseconds (default = 20 ms)
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeAssertions.Be(System.DateTime,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of milliseconds which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeCloseTo(System.DateTime,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is within the specified time
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeAssertions.Be(System.DateTime,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotBeCloseTo(System.DateTime,System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is not within the specified number of milliseconds (default = 20 ms)
            from the specified <paramref name="distantTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeAssertions.NotBe(System.DateTime,System.String,System.Object[])"/>.
            </remarks>
            <param name="distantTime">
            The time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of milliseconds which the two values must differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotBeCloseTo(System.DateTime,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is not within the specified time
            from the specified <paramref name="distantTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeAssertions.NotBe(System.DateTime,System.String,System.Object[])"/>.
            </remarks>
            <param name="distantTime">
            The time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values must differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotBeBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is not before the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTime"/>  that the current value is not expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeOnOrBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is either on, or before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be on or before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotBeOnOrBefore(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is neither on, nor before the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTime"/>  that the current value is not expected to be on nor before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotBeAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is not after the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTime"/>  that the current value is not expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeOnOrAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is either on, or after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTime"/>  that the current value is expected to be on or after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotBeOnOrAfter(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  is neither on, nor after the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTime"/>  that the current value is expected not to be on nor after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> has the <paramref name="expected"/> year.
            </summary>
            <param name="expected">The expected year of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotHaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> year.
            </summary>
            <param name="unexpected">The year that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> has the <paramref name="expected"/> month.
            </summary>
            <param name="expected">The expected month of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotHaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> month.
            </summary>
            <param name="unexpected">The month that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> day.
            </summary>
            <param name="expected">The expected day of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotHaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> day.
            </summary>
            <param name="unexpected">The day that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> hour.
            </summary>
            <param name="expected">The expected hour of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotHaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> hour.
            </summary>
            <param name="unexpected">The hour that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> minute.
            </summary>
            <param name="expected">The expected minutes of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotHaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> minute.
            </summary>
            <param name="unexpected">The minute that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.HaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/>  has the <paramref name="expected"/> second.
            </summary>
            <param name="expected">The expected seconds of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotHaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> does not have the <paramref name="unexpected"/> second.
            </summary>
            <param name="unexpected">The second that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeMoreThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should exceed compared to another <see cref="T:System.DateTime"/> .
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeAtLeast(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            is equal to or exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should be equal or exceed compared to
            another <see cref="T:System.DateTime"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeExactly(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            differs exactly the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should differ exactly compared to another <see cref="T:System.DateTime"/> .
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeWithin(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            is within the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTime"/>  should be within another <see cref="T:System.DateTime"/> .
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeLessThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTime"/>
            differs at maximum the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTime"/> .
            </summary>
            <param name="timeSpan">
            The maximum amount of time that the current <see cref="T:System.DateTime"/>  should differ compared to another <see cref="T:System.DateTime"/> .
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeSameDateAs(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> has the <paramref name="expected"/> date.
            </summary>
            <param name="expected">The expected date portion of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.NotBeSameDateAs(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTime"/> is not the <paramref name="unexpected"/> date.
            </summary>
            <param name="unexpected">The date that is not to match the date portion of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeOneOf(System.Nullable{System.DateTime}[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeOneOf(System.DateTime[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeOneOf(System.Collections.Generic.IEnumerable{System.DateTime},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeOneOf(System.Collections.Generic.IEnumerable{System.Nullable{System.DateTime}},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeAssertions.BeIn(System.DateTimeKind,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTime"/> represents a value in the <paramref name="expectedKind"/>.
            </summary>
            <param name="expectedKind">
            The expected <see cref="T:System.DateTimeKind"/> that the current value must represent.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeOffsetAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTimeOffset"/>.
            </remarks>
        </member>
        <member name="P:FluentAssertions.Primitives.DateTimeOffsetAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.Be(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is exactly equal to the <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBe(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not equal to the <paramref name="unexpected"/> value.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeCloseTo(System.DateTimeOffset,System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is within the specified number of milliseconds (default = 20 ms)
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.Be(System.DateTimeOffset,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of milliseconds which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeCloseTo(System.DateTimeOffset,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is within the specified time
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.Be(System.DateTimeOffset,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBeCloseTo(System.DateTimeOffset,System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not within the specified number of milliseconds (default = 20 ms)
            from the specified <paramref name="distantTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBe(System.DateTimeOffset,System.String,System.Object[])"/>.
            </remarks>
            <param name="distantTime">
            The time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of milliseconds which the two values must differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBeCloseTo(System.DateTimeOffset,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not within the specified time
            from the specified <paramref name="distantTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBe(System.DateTimeOffset,System.String,System.Object[])"/>.
            </remarks>
            <param name="distantTime">
            The time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values must differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBeBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/>  is not before the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTimeOffset"/>  that the current value is not expected to be before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeOnOrBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is either on, or before the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be on or before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBeOnOrBefore(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is neither on, nor before the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTimeOffset"/> that the current value is not expected to be on nor before.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBeAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not after the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTimeOffset"/> that the current value is not expected to be after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeOnOrAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is either on, or after the specified value.
            </summary>
            <param name="expected">The <see cref="T:System.DateTimeOffset"/> that the current value is expected to be on or after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBeOnOrAfter(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/>  is neither on, nor after the specified value.
            </summary>
            <param name="unexpected">The <see cref="T:System.DateTimeOffset"/>  that the current value is expected not to be on nor after.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> year.
            </summary>
            <param name="expected">The expected year of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotHaveYear(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> year.
            </summary>
            <param name="unexpected">The year that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> month.
            </summary>
            <param name="expected">The expected month of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotHaveMonth(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> month.
            </summary>
            <param name="unexpected">The month that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> day.
            </summary>
            <param name="expected">The expected day of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotHaveDay(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> day.
            </summary>
            <param name="unexpected">The day that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> hour.
            </summary>
            <param name="expected">The expected hour of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotHaveHour(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> hour.
            </summary>
            <param name="unexpected">The hour that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> minute.
            </summary>
            <param name="expected">The expected minutes of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotHaveMinute(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> minute.
            </summary>
            <param name="unexpected">The minute that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> second.
            </summary>
            <param name="expected">The expected seconds of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotHaveSecond(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> second.
            </summary>
            <param name="unexpected">The second that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.HaveOffset(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> offset.
            </summary>
            <param name="expected">The expected offset of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotHaveOffset(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> does not have the <paramref name="unexpected"/> offset.
            </summary>
            <param name="unexpected">The offset that should not be in the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeMoreThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should exceed compared to another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeAtLeast(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            is equal to or exceeds the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should be equal or exceed compared to
            another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeExactly(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            differs exactly the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should differ exactly compared to another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeWithin(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            is within the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The amount of time that the current <see cref="T:System.DateTimeOffset"/> should be within another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeLessThan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions"/> object that can be used to assert that the current <see cref="T:System.DateTimeOffset"/>
            differs at maximum the specified <paramref name="timeSpan"/> compared to another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="timeSpan">
            The maximum amount of time that the current <see cref="T:System.DateTimeOffset"/> should differ compared to another <see cref="T:System.DateTimeOffset"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeSameDateAs(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> has the <paramref name="expected"/> date.
            </summary>
            <param name="expected">The expected date portion of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.NotBeSameDateAs(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.DateTimeOffset"/> is not the <paramref name="unexpected"/> date.
            </summary>
            <param name="unexpected">The date that is not to match the date portion of the current value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeOneOf(System.Nullable{System.DateTimeOffset}[])">
            <summary>
            Asserts that the <see cref="T:System.DateTimeOffset"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeOneOf(System.DateTimeOffset[])">
            <summary>
            Asserts that the <see cref="T:System.DateTimeOffset"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeOneOf(System.Collections.Generic.IEnumerable{System.DateTimeOffset},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTimeOffset"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetAssertions.BeOneOf(System.Collections.Generic.IEnumerable{System.Nullable{System.DateTimeOffset}},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.DateTimeOffset"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions">
            <summary>
            Contains a number of methods to assert that two <see cref="T:System.DateTime"/> objects differ in the expected way.
            </summary>
            <remarks>
            You can use the <see cref="!:FluentDateTimeExtensions"/> and <see cref="!:TimeSpanConversionExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTime"/> or a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions.Before(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTimeOffset"/> occurs a specified amount of time before another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTimeOffset"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeOffsetRangeAssertions.After(System.DateTimeOffset,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTimeOffset"/> occurs a specified amount of time after another <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTimeOffset"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.DateTimeRangeAssertions">
            <summary>
            Contains a number of methods to assert that two <see cref="T:System.DateTime"/> objects differ in the expected way.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/> and
            <see cref="T:FluentAssertions.Extensions.FluentTimeSpanExtensions"/> for a more fluent
            way of specifying a <see cref="T:System.DateTime"/> or a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeRangeAssertions.Before(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTime"/> occurs a specified amount of time before another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTime"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.DateTimeRangeAssertions.After(System.DateTime,System.String,System.Object[])">
            <summary>
            Asserts that a <see cref="T:System.DateTime"/> occurs a specified amount of time after another <see cref="T:System.DateTime"/>.
            </summary>
            <param name="target">
            The <see cref="T:System.DateTime"/> to compare the subject with.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.GuidAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Guid"/> is in the correct state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.GuidAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is <see cref="F:System.Guid.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is not <see cref="F:System.Guid.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.Be(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is equal to the <paramref name="expected"/> GUID.
            </summary>
            <param name="expected">The expected <see cref="T:System.String"/> value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.Be(System.Guid,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is equal to the <paramref name="expected"/> GUID.
            </summary>
            <param name="expected">The expected value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.GuidAssertions.NotBe(System.Guid,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.Guid"/> is not equal to the <paramref name="unexpected"/> GUID.
            </summary>
            <param name="unexpected">The unexpected value to compare the actual value with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableBooleanAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.Boolean"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable boolean value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.Be(System.Nullable{System.Boolean},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.NotBeFalse(System.String,System.Object[])">
            <summary>
            Asserts that the value is not <c>false</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableBooleanAssertions.NotBeTrue(System.String,System.Object[])">
            <summary>
            Asserts that the value is not <c>true</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableDateTimeAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.DateTime"/> or
            <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="!:FluentDateTimeExtensions"/> for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTime"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeAssertions.Be(System.Nullable{System.DateTime},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.DateTimeOffset"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentDateTimeExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.DateTimeOffset"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableDateTimeOffsetAssertions.Be(System.Nullable{System.DateTimeOffset},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableGuidAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.Guid"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.Guid"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableGuidAssertions.Be(System.Nullable{System.Guid},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.TimeSpan"/> is in the expected state.
            </summary>
            <remarks>
            You can use the <see cref="T:FluentAssertions.Extensions.FluentTimeSpanExtensions"/>
            for a more fluent way of specifying a <see cref="T:System.TimeSpan"/>.
            </remarks>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions.HaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is not <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions.NotHaveValue(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that a nullable <see cref="T:System.TimeSpan"/> value is <c>null</c>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because"/>.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions.Be(System.Nullable{System.TimeSpan},System.String,System.Object[])">
            <summary>
            Asserts that the value is equal to the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.ObjectAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Object"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.Be(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that an object equals another object using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.NotBe(System.Object,System.String,System.Object[])">
            <summary>
            Asserts that an object does not equal another object using its <see cref="M:System.Object.Equals(System.Object)" /> method.
            </summary>
            <param name="unexpected">The unexpected value</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.BeEquivalentTo``1(``0,System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            Notice that actual behavior is determined by the global defaults managed by <see cref="T:FluentAssertions.AssertionOptions"/>.
            </remarks>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.BeEquivalentTo``1(``0,System.Func{FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0},FluentAssertions.Equivalency.EquivalencyAssertionOptions{``0}},System.String,System.Object[])">
            <summary>
            Asserts that an object is equivalent to another object.
            </summary>
            <remarks>
            Objects are equivalent when both object graphs have equally named properties with the same value,
            irrespective of the type of those objects. Two properties are also equal if one type can be converted to another and the result is equal.
            The type of a collection property is ignored as long as the collection implements <see cref="T:System.Collections.Generic.IEnumerable`1"/> and all
            items in the collection are structurally equal.
            </remarks>
            <param name="config">
            A reference to the <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> configuration object that can be used
            to influence the way the object graphs are compared. You can also provide an alternative instance of the
            <see cref="T:FluentAssertions.Equivalency.EquivalencyAssertionOptions`1"/> class. The global defaults are determined by the
            <see cref="T:FluentAssertions.AssertionOptions"/> class.
            </param>
            <param name="because">
            An optional formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the
            assertion is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.HaveFlag(System.Enum,System.String,System.Object[])">
            <summary>
            Asserts that an object is an enum and has a specified flag
            </summary>
            <param name="expectedFlag">The expected flag.</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ObjectAssertions.NotHaveFlag(System.Enum,System.String,System.Object[])">
            <summary>
            Asserts that an object is an enum and does not have a specified flag
            </summary>
            <param name="unexpectedFlag">The unexpected flag.</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.ObjectAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.ReferenceTypeAssertions`2">
            <summary>
            Contains a number of methods to assert that a reference type object is in the expected state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeNull(System.String,System.Object[])">
            <summary>
            Asserts that the current object has not been initialized yet.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeNull(System.String,System.Object[])">
            <summary>
            Asserts that the current object has been initialized.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeSameAs(`0,System.String,System.Object[])">
            <summary>
            Asserts that an object reference refers to the exact same object as another object reference.
            </summary>
            <param name="expected">The expected object</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeSameAs(`0,System.String,System.Object[])">
            <summary>
            Asserts that an object reference refers to a different object than another object reference refers to.
            </summary>
            <param name="unexpected">The unexpected object</param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeOfType``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is of the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The expected type of the object.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is of the specified type <paramref name="expectedType"/>.
            </summary>
            <param name="expectedType">
            The type that the subject is supposed to be of.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeOfType``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is not of the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type that the subject is not supposed to be of.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeOfType(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is not of the specified type <paramref name="expectedType"/>.
            </summary>
            <param name="expectedType">
            The type that the subject is not supposed to be of.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is assignable to a variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which the object should be assignable.</typeparam>
            <param name="because">The reason why the object should be assignable to the type.</param>
            <param name="becauseArgs">The parameters used when formatting the <paramref name="because"/>.</param>
            <returns>An <see cref="T:FluentAssertions.AndWhichConstraint`2"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.BeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is assignable to a variable of given <paramref name="type"/>.
            </summary>
            <param name="type">The type to which the object should be assignable.</param>
            <param name="because">The parameters used when formatting the <paramref name="because"/>.</param>
            <param name="becauseArgs"></param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts that the object is not assignable to a variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which the object should not be assignable.</typeparam>
            <param name="because">The reason why the object should not be assignable to the type.</param>
            <param name="becauseArgs">The parameters used when formatting the <paramref name="because"/>.</param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.NotBeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the object is not assignable to a variable of given <paramref name="type"/>.
            </summary>
            <param name="type">The type to which the object should not be assignable.</param>
            <param name="because">The parameters used when formatting the <paramref name="because"/>.</param>
            <param name="becauseArgs"></param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Match(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="predicate" /> is satisfied.
            </summary>
            <param name="predicate">The predicate which must be satisfied by the <typeparamref name="TSubject" />.</param>
            <param name="because">The reason why the predicate should be satisfied.</param>
            <param name="becauseArgs">The parameters used when formatting the <paramref name="because" />.</param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1" /> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Match``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the <paramref name="predicate" /> is satisfied.
            </summary>
            <param name="predicate">The predicate which must be satisfied by the <typeparamref name="TSubject" />.</param>
            <param name="because">The reason why the predicate should be satisfied.</param>
            <param name="becauseArgs">The parameters used when formatting the <paramref name="because" />.</param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1" /> which can be used to chain assertions.</returns>
        </member>
        <member name="P:FluentAssertions.Primitives.ReferenceTypeAssertions`2.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.SimpleTimeSpanAssertions">
            <summary>
            Contains a number of methods to assert that a nullable <see cref="T:System.TimeSpan"/> is in the expected state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.SimpleTimeSpanAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BePositive(System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is greater than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeNegative(System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is less than zero.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.Be(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is equal to the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The expected time difference</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.NotBe(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is not equal to the
            specified <paramref name="unexpected"/> time.
            </summary>
            <param name="unexpected">The unexpected time difference</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeLessThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is less than the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeLessOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is less than or equal to the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeGreaterThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is greater than the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeGreaterOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the time difference of the current <see cref="T:System.TimeSpan"/> is greater than or equal to the
            specified <paramref name="expected"/> time.
            </summary>
            <param name="expected">The time difference to which the current value will be compared</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeCloseTo(System.TimeSpan,System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.TimeSpan"/> is within the specified number of milliseconds (default = 20 ms)
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.Be(System.TimeSpan,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of milliseconds which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.BeCloseTo(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.TimeSpan"/> is within the specified time
            from the specified <paramref name="nearbyTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.Be(System.TimeSpan,System.String,System.Object[])"/>.
            </remarks>
            <param name="nearbyTime">
            The expected time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.NotBeCloseTo(System.TimeSpan,System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.TimeSpan"/> is not within the specified number of milliseconds (default = 20 ms)
            from the specified <paramref name="distantTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.NotBe(System.TimeSpan,System.String,System.Object[])"/>.
            </remarks>
            <param name="distantTime">
            The time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of milliseconds which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.NotBeCloseTo(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.TimeSpan"/> is not within the specified time
            from the specified <paramref name="distantTime"/> value.
            </summary>
            <remarks>
            Use this assertion when, for example the database truncates datetimes to nearest 20ms. If you want to assert to the exact datetime,
            use <see cref="M:FluentAssertions.Primitives.SimpleTimeSpanAssertions.NotBe(System.TimeSpan,System.String,System.Object[])"/>.
            </remarks>
            <param name="distantTime">
            The time to compare the actual value with.
            </param>
            <param name="precision">
            The maximum amount of time which the two values may differ.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Primitives.StringAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.String"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.Be(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is exactly the same as another string, including the casing and any leading or trailing whitespace.
            </summary>
            <param name="expected">The expected string.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeOneOf(System.String[])">
            <summary>
            Asserts that the <see cref="T:System.String"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeOneOf(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="T:System.String"/> is one of the specified <paramref name="validValues"/>.
            </summary>
            <param name="validValues">
            The values that are valid.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeEquivalentTo(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is exactly the same as another string, including any leading or trailing whitespace, with
            the exception of the casing.
            </summary>
            <param name="expected">
            The string that the subject is expected to be equivalent to.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotBe(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string is not exactly the same as the specified <paramref name="unexpected"/>,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="unexpected">The string that the subject is not expected to be equivalent to.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.Match(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string matches a wildcard pattern.
            </summary>
            <param name="wildcardPattern">
            The wildcard pattern with which the subject is matched, where * and ? have special meanings.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotMatch(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match a wildcard pattern.
            </summary>
            <param name="wildcardPattern">
            The wildcard pattern with which the subject is matched, where * and ? have special meanings.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.MatchEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string matches a wildcard pattern.
            </summary>
            <param name="wildcardPattern">
            The wildcard pattern with which the subject is matched, where * and ? have special meanings.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotMatchEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match a wildcard pattern.
            </summary>
            <param name="wildcardPattern">
            The wildcard pattern with which the subject is matched, where * and ? have special meanings.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.MatchRegex(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string matches a regular expression.
            </summary>
            <param name="regularExpression">
            The regular expression with which the subject is matched.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotMatchRegex(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not match a regular expression.
            </summary>
            <param name="regularExpression">
            The regular expression with which the subject is matched.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.StartWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string starts exactly with the specified <paramref name="expected"/> value,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="expected">The string that the subject is expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotStartWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not start with the specified <paramref name="unexpected"/> value,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="unexpected">The string that the subject is not expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.StartWithEquivalent(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string starts with the specified <paramref name="expected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">The string that the subject is expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotStartWithEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not start with the specified <paramref name="unexpected"/> value,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to start with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.EndWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string ends exactly with the specified <paramref name="expected"/>,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="expected">The string that the subject is expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotEndWith(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not end exactly with the specified <paramref name="unexpected"/>,
            including the casing and any leading or trailing whitespace.
            </summary>
            <param name="unexpected">The string that the subject is not expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.EndWithEquivalent(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string ends with the specified <paramref name="expected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">The string that the subject is expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotEndWithEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not end with the specified <paramref name="unexpected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to end with.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.Contain(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string contains another (fragment of a) string.
            </summary>
            <param name="expected">
            The (fragment of a) string that the current string should contain.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.ContainEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string contains the specified <paramref name="expected"/>,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="expected">The string that the subject is expected to contain.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.ContainAll(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a string contains all values present in <paramref name="values"/>.
            </summary>
            <param name="values">
            The values that should all be present in the string
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.ContainAll(System.String[])">
            <summary>
            Asserts that a string contains all values present in <paramref name="values"/>.
            </summary>
            <param name="values">
            The values that should all be present in the string
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.ContainAny(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a string contains at least one value present in <paramref name="values"/>,.
            </summary>
            <param name="values">
            The values that should will be tested against the string
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.ContainAny(System.String[])">
            <summary>
            Asserts that a string contains at least one value present in <paramref name="values"/>,.
            </summary>
            <param name="values">
            The values that should will be tested against the string
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotContain(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain another (fragment of a) string.
            </summary>
            <param name="expected">
            The (fragment of a) string that the current string should not contain.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotContainAll(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain all of the strings provided in <paramref name="values"/>. The string
            may contain some subset of the provided values.
            </summary>
            <param name="values">
            The values that should not be present in the string
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotContainAll(System.String[])">
            <summary>
            Asserts that a string does not contain all of the strings provided in <paramref name="values"/>. The string
            may contain some subset of the provided values.
            </summary>
            <param name="values">
            The values that should not be present in the string
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotContainAny(System.Collections.Generic.IEnumerable{System.String},System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain any of the strings provided in <paramref name="values"/>.
            </summary>
            <param name="values">
            The values that should not be present in the string
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotContainAny(System.String[])">
            <summary>
            Asserts that a string does not contain any of the strings provided in <paramref name="values"/>.
            </summary>
            <param name="values">
            The values that should not be present in the string
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotContainEquivalentOf(System.String,System.String,System.Object[])">
            <summary>
            Asserts that a string does not contain the specified <paramref name="unexpected"/> string,
            including any leading or trailing whitespace, with the exception of the casing.
            </summary>
            <param name="unexpected">The string that the subject is not expected to contain.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotBeEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is not <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.HaveLength(System.Int32,System.String,System.Object[])">
            <summary>
            Asserts that a string has the specified <paramref name="expected"/> length.
            </summary>
            <param name="expected">The expected length of the string</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotBeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is neither <c>null</c> nor <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeNullOrEmpty(System.String,System.Object[])">
            <summary>
            Asserts that a string is either <c>null</c> or <see cref="F:System.String.Empty"/>.
            </summary>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.NotBeNullOrWhiteSpace(System.String,System.Object[])">
            <summary>
            Asserts that a string is neither <c>null</c> nor <see cref="F:System.String.Empty"/> nor white space
            </summary>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Primitives.StringAssertions.BeNullOrWhiteSpace(System.String,System.Object[])">
            <summary>
            Asserts that a string is either <c>null</c> or <see cref="F:System.String.Empty"/> or white space
            </summary>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="P:FluentAssertions.Primitives.StringAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.StringValidator">
            <summary>
            Dedicated class for comparing two strings and generating consistent error messages.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.StringWildcardMatchingValidator.Negate">
            <summary>
            Gets or sets a value indicating whether the subject should not match the pattern.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.StringWildcardMatchingValidator.IgnoreCase">
            <summary>
            Gets or sets a value indicating whether the matching process should ignore any casing difference.
            </summary>
        </member>
        <member name="P:FluentAssertions.Primitives.StringWildcardMatchingValidator.IgnoreNewLineDifferences">
            <summary>
            Ignores the difference between environment newline differences
            </summary>
        </member>
        <member name="T:FluentAssertions.Primitives.TimeSpanPredicate">
            <summary>
            Provides the logic and the display text for a <see cref="T:FluentAssertions.Primitives.TimeSpanCondition"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Specialized.ActionAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Action"/> yields the expected result.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.ActionAssertions.Throw``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Action"/> throws an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ActionAssertions.NotThrow``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Action"/> does not throw an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ActionAssertions.NotThrow(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Action"/> does not throw any exception.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Specialized.ActionAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Specialized.AsyncFunctionAssertions">
            <summary>
            Contains a number of methods to assert that an asynchronous method yields the expected result.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.AsyncFunctionAssertions.Subject">
            <summary>
            Gets the <see cref="T:System.Func`1"/> that is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions.Throw``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> throws an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions.NotThrow(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> does not throw any exception.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.AsyncFunctionAssertions.NotThrow``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Func`1"/> does not throw an exception of type <typeparamref name="TException"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Specialized.ExceptionAssertions`1">
            <summary>
              Contains a number of methods to assert that an <see cref = "T:System.Exception" /> is in the correct state.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.ExceptionAssertions`1.And">
            <summary>
              Gets the exception object of the exception thrown.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.ExceptionAssertions`1.Which">
            <summary>
              Gets the exception object of the exception thrown.
            </summary>
        </member>
        <member name="P:FluentAssertions.Specialized.ExceptionAssertions`1.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithMessage(System.String,System.String,System.Object[])">
            <summary>
              Asserts that the thrown exception has a message that matches <paramref name = "expectedMessage" />
              depending on the specified matching mode.
            </summary>
            <param name = "expectedMessage">
              The expected message of the exception.
            </param>
            <param name = "because">
              A formatted phrase as is supported by <see cref = "M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
              is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name = "becauseArgs">
              Zero or more objects to format using the placeholders in <see cref = "!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerException``1(System.String,System.Object[])">
            <summary>
              Asserts that the thrown exception contains an inner exception of type <typeparamref name = "TInnerException" />.
            </summary>
            <typeparam name = "TInnerException">The expected type of the inner exception.</typeparam>
            <param name = "because">The reason why the inner exception should be of the supplied type.</param>
            <param name = "becauseArgs">The parameters used when formatting the <paramref name = "because" />.</param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.WithInnerExceptionExactly``1(System.String,System.Object[])">
            <summary>
              Asserts that the thrown exception contains an inner exception of the exact type <typeparamref name = "TInnerException" /> (and not a derived exception type).
            </summary>
            <typeparam name = "TInnerException">The expected type of the inner exception.</typeparam>
            <param name = "because">The reason why the inner exception should be of the supplied type.</param>
            <param name = "becauseArgs">The parameters used when formatting the <paramref name = "because" />.</param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExceptionAssertions`1.Where(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.String,System.Object[])">
            <summary>
              Asserts that the exception matches a particular condition.
            </summary>
            <param name = "exceptionExpression">
              The condition that the exception must match.
            </param>
            <param name = "because">
              A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
              start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name = "becauseArgs">
              Zero or more values to use for filling in any <see cref = "M:System.String.Format(System.String,System.Object[])" /> compatible placeholders.
            </param>
        </member>
        <member name="T:FluentAssertions.Specialized.ExecutionTimeAssertions">
            <summary>
            Provides methods for asserting that the execution time of an <see cref="T:System.Action"/> satisfies certain conditions.
            </summary>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.#ctor(FluentAssertions.Specialized.ExecutionTime)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Specialized.ExecutionTime"/> class.
            </summary>
            <param name="executionTime">The execution on which time must be asserted.</param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.PollUntil(System.Func{System.TimeSpan,System.Boolean},System.Boolean,System.TimeSpan)">
            <summary>
            Checks the executing action if it satisfies a condition.
            If the execution runs into an exeption, then this will rethrow it.
            </summary>
            <param name="condition">Condition to check on the current elapsed time.</param>
            <param name="expectedResult">Polling stops when condition returns the expected result.</param>
            <param name="rate">The rate at which the condition is re-checked.</param>
            <return>The elapsed time. (use this, don't measure twice)</return>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeLessOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is less or equal to a specified amount of time.
            </summary>
            <param name="maxDuration">
            The maximum allowed duration.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeLessThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is less than a specified amount of time.
            </summary>
            <param name="maxDuration">
            The maximum allowed duration.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeGreaterOrEqualTo(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is greater or equal to a specified amount of time.
            </summary>
            <param name="minDuration">
            The minimum allowed duration.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeGreaterThan(System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is greater than a specified amount of time.
            </summary>
            <param name="minDuration">
            The minimum allowed duration.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTimeAssertions.BeCloseTo(System.TimeSpan,System.TimeSpan,System.String,System.Object[])">
            <summary>
            Asserts that the execution time of the operation is within the expected duration.
            by a specified precision.
            </summary>
            <param name="expectedDuration">
            The expected duration.
            </param>
            <param name="precision">
            The maximum amount of time which the execution time may differ from the expected duration.
            </param>
            <param name="because">
            A formatted phrase explaining why the assertion should be satisfied. If the phrase does not
            start with the word <i>because</i>, it is prepended to the message.
            </param>
            <param name="becauseArgs">
            Zero or more values to use for filling in any <see cref="M:System.String.Format(System.String,System.Object[])"/> compatible placeholders.
            </param>
        </member>
        <member name="M:FluentAssertions.Specialized.ExecutionTime.#ctor(System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Specialized.ExecutionTime"/> class.
            </summary>
            <param name="action">The action of which the execution time must be asserted.</param>
        </member>
        <member name="M:FluentAssertions.Specialized.MemberExecutionTime`1.#ctor(`0,System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Specialized.MemberExecutionTime`1"/> class.
            </summary>
            <param name="subject">The object that exposes the method or property.</param>
            <param name="action">A reference to the method or property to measure the execution time of.</param>
        </member>
        <member name="T:FluentAssertions.Reflection.AssemblyAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Reflection.Assembly"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.#ctor(System.Reflection.Assembly)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Reflection.AssemblyAssertions" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.NotReference(System.Reflection.Assembly)">
            <summary>
            Asserts that an assembly does not reference the specified assembly.
            </summary>
            <param name="assembly">The assembly which should not be referenced.</param>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.NotReference(System.Reflection.Assembly,System.String,System.String[])">
            <summary>
            Asserts that an assembly does not reference the specified assembly.
            </summary>
            <param name="assembly">The assembly which should not be referenced.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.Reference(System.Reflection.Assembly)">
            <summary>
            Asserts that an assembly references the specified assembly.
            </summary>
            <param name="assembly">The assembly which should be referenced.</param>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.Reference(System.Reflection.Assembly,System.String,System.String[])">
            <summary>
            Asserts that an assembly references the specified assembly.
            </summary>
            <param name="assembly">The assembly which should be referenced.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Reflection.AssemblyAssertions.DefineType(System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the Assembly defines a type called <paramref name="namespace"/> and <paramref name="name"/>.
            </summary>
            <param name="namespace">The namespace of the class.</param>
            <param name="name">The name of the class.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="P:FluentAssertions.Reflection.AssemblyAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.TypeEnumerableExtensions">
            <summary>
            Extension methods for filtering a collection of types.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreDecoratedWith``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreDecoratedWithOrInherit``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types decorated with, or inherits from a parent class, a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreNotDecoratedWith``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types not decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreNotDecoratedWithOrInherit``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types not decorated with and does not inherit from a parent class, a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreInNamespace(System.Collections.Generic.IEnumerable{System.Type},System.String)">
            <summary>
            Filters to only include types where the namespace of type is exactly <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatAreUnderNamespace(System.Collections.Generic.IEnumerable{System.Type},System.String)">
            <summary>
            Filters to only include types where the namespace of type is starts with <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatDeriveFrom``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Filters to only include types that subclass the specified type, but NOT the same type.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeEnumerableExtensions.ThatImplement``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Determines whether a type implements an interface (but is not the interface itself).
            </summary>
        </member>
        <member name="T:FluentAssertions.TypeExtensions">
            <summary>
            Extension methods for getting method and property selectors for a type.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Types(System.Reflection.Assembly)">
            <summary>
            Returns the types that are visible outside the specified <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Types(System.Type)">
            <summary>
            Returns a type selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Types(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Returns a type selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Methods(System.Type)">
            <summary>
            Returns a method selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Methods(FluentAssertions.Types.TypeSelector)">
            <summary>
            Returns a method selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Properties(System.Type)">
            <summary>
            Returns a property selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.TypeExtensions.Properties(FluentAssertions.Types.TypeSelector)">
            <summary>
            Returns a property selector for the current <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.AllTypes">
            <summary>
            Static class that allows for a 'fluent' selection of the types from an <see cref="T:System.Reflection.Assembly"/>.
            </summary>
            <example>
            AllTypes.From(myAssembly)<br />
              .ThatImplement&lt;ISomeInterface&gt;<br />
              .Should()<br />
              .BeDecoratedWith&lt;SomeAttribute&gt;()
            </example>
        </member>
        <member name="M:FluentAssertions.Types.AllTypes.From(System.Reflection.Assembly)">
            <summary>
            Returns a <see cref="T:FluentAssertions.Types.TypeSelector"/> for selecting the types that are visible outside the
            specified <paramref name="assembly"/>.
            </summary>
            <param name="assembly">The assembly from which to select the types.</param>
        </member>
        <member name="T:FluentAssertions.Types.ConstructorInfoAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.ConstructorInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.ConstructorInfoAssertions.#ctor(System.Reflection.ConstructorInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.ConstructorInfoAssertions"/> class.
            </summary>
            <param name="constructorInfo">The constructorInfo from which to select properties.</param>
        </member>
        <member name="T:FluentAssertions.Types.MemberInfoAssertions`2">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.MemberInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected member is decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected member is not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected member is decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MemberInfoAssertions`2.NotBeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected member is not decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Types.MethodBaseAssertions`2">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.MethodBase"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodBaseAssertions`2.HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected member has the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodBaseAssertions`2.NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected member does not have the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The unexpected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Types.MethodInfoAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.MethodInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotBeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is not virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.BeAsync(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is async.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotBeAsync(System.String,System.Object[])">
            <summary>
            Asserts that the selected method is not async.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.ReturnVoid(System.String,System.Object[])">
            <summary>
            Asserts that the selected MethodInfo returns void.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.Return(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected MethodInfo returns <paramref name="returnType"/>.
            </summary>
            <param name="returnType">The expected return type.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.Return``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected MethodInfo returns <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The expected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotReturnVoid(System.String,System.Object[])">
            <summary>
            Asserts that the selected MethodInfo does not return void.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotReturn(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected MethodInfo does not return <paramref name="returnType"/>.
            </summary>
            <param name="returnType">The unexpected return type.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoAssertions.NotReturn``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected MethodInfo does not return <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The unexpected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Types.MethodInfoSelector">
            <summary>
            Allows for fluent selection of methods of a type through reflection.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.MethodInfoSelector"/> class.
            </summary>
            <param name="type">The type from which to select methods.</param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.MethodInfoSelector"/> class.
            </summary>
            <param name="types">The types from which to select methods.</param>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelector.ThatArePublicOrInternal">
            <summary>
            Only select the methods that are public or internal.
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelector.ThatReturnVoid">
            <summary>
            Only select the methods without a return value
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelector.ThatDoNotReturnVoid">
            <summary>
            Only select the methods with a return value
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatReturn``1">
            <summary>
            Only select the methods that return the specified type
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatDoNotReturn``1">
            <summary>
            Only select the methods that do not return the specified type
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreDecoratedWith``1">
            <summary>
            Only select the methods that are decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreDecoratedWithOrInherit``1">
            <summary>
            Only select the methods that are decorated with, or inherits from a parent class, an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreNotDecoratedWith``1">
            <summary>
            Only select the methods that are not decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ThatAreNotDecoratedWithOrInherit``1">
            <summary>
            Only select the methods that are not decorated with and does not inherit from a parent class, an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.ToArray">
            <summary>
            The resulting <see cref="T:System.Reflection.MethodInfo"/> objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.HasSpecialName(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method has a special name (like properties and events).
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Types.MethodInfoSelectorAssertions">
            <summary>
            Contains assertions for the <see cref="T:System.Reflection.MethodInfo"/> objects returned by the parent <see cref="T:FluentAssertions.Types.MethodInfoSelector"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.#ctor(System.Reflection.MethodInfo[])">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.MethodInfoSelectorAssertions"/> class.
            </summary>
            <param name="methodInfo">The methods to assert.</param>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelectorAssertions.SubjectMethods">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.NotBeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are not virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.MethodInfoSelectorAssertions.NotBeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the selected methods are not decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.MethodInfoSelectorAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.PropertyInfoAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Reflection.PropertyInfo"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected property is virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotBeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected property is not virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeWritable(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a setter with the specified C# access modifier.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotBeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property does not have a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeReadable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a getter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.BeReadable(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected property has a getter with the specified C# access modifier.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotBeReadable(System.String,System.Object[])">
            <summary>
            Asserts that the selected property does not have a getter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.Return(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected property returns a specified type.
            </summary>
            <param name="propertyType">The expected type of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.Return``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected PropertyInfo returns <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The expected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotReturn(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the selected property does not return a specified type.
            </summary>
            <param name="propertyType">The unexpected type of the property.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoAssertions.NotReturn``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected PropertyInfo does not return <typeparamref name="TReturn"/>.
            </summary>
            <typeparam name="TReturn">The unexpected return type.</typeparam>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.PropertyInfoSelector">
            <summary>
            Allows for fluent selection of properties of a type through reflection.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/> class.
            </summary>
            <param name="type">The type from which to select properties.</param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/> class.
            </summary>
            <param name="types">The types from which to select properties.</param>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoSelector.ThatArePublicOrInternal">
            <summary>
            Only select the properties that have a public or internal getter.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ThatAreDecoratedWith``1">
            <summary>
            Only select the properties that are decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ThatAreDecoratedWithOrInherit``1">
            <summary>
            Only select the properties that are decorated with, or inherits from a parent class, an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ThatAreNotDecoratedWith``1">
            <summary>
            Only select the properties that are not decorated with an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ThatAreNotDecoratedWithOrInherit``1">
            <summary>
            Only select the properties that are not decorated with and does not inherit from a parent class an attribute of the specified type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.OfType``1">
            <summary>
            Only select the properties that return the specified type
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.NotOfType``1">
            <summary>
            Only select the properties that do not return the specified type
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.ToArray">
            <summary>
            The resulting <see cref="T:System.Reflection.PropertyInfo"/> objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Types.PropertyInfoSelectorAssertions">
            <summary>
            Contains assertions for the <see cref="T:System.Reflection.PropertyInfo"/> objects returned by the parent <see cref="T:FluentAssertions.Types.PropertyInfoSelector"/>.
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoSelectorAssertions.SubjectProperties">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.#ctor(System.Reflection.PropertyInfo[])">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Types.PropertyInfoSelectorAssertions"/> class, for a number of <see cref="T:System.Reflection.PropertyInfo"/> objects.
            </summary>
            <param name="properties">The properties to assert.</param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.BeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.NotBeVirtual(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are not virtual.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.BeWritable(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties have a setter.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.PropertyInfoSelectorAssertions.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the selected properties are not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Types.PropertyInfoSelectorAssertions.Context">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.TypeAssertions">
            <summary>
            Contains a number of methods to assert that a <see cref="T:System.Type"/> meets certain expectations.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Be``1(System.String,System.Object[])">
            <summary>
            Asserts that the current type is equal to the specified <typeparamref name="TExpected"/> type.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Be(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current type is equal to the specified <paramref name="expected"/> type.
            </summary>
            <param name="expected">The expected type</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts than an instance of the subject type is assignable variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which instances of the type should be assignable.</typeparam>
            <param name="because">The reason why instances of the type should be assignable to the type.</param>
            <param name="becauseArgs">The parameters used when formatting the <paramref name="because"/>.</param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts than an instance of the subject type is assignable variable of given <paramref name="type"/>.
            </summary>
            <param name="type">The type to which instances of the type should be assignable.</param>
            <param name="because">The reason why instances of the type should be assignable to the type.</param>
            <param name="becauseArgs"></param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeAssignableTo``1(System.String,System.Object[])">
            <summary>
            Asserts than an instance of the subject type is not assignable variable of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to which instances of the type should not be assignable.</typeparam>
            <param name="because">The reason why instances of the type should not be assignable to the type.</param>
            <param name="becauseArgs">The parameters used when formatting the <paramref name="because"/>.</param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeAssignableTo(System.Type,System.String,System.Object[])">
            <summary>
            Asserts than an instance of the subject type is not assignable variable of given <paramref name="type"/>.
            </summary>
            <param name="type">The type to which instances of the type should not be assignable.</param>
            <param name="because">The reason why instances of the type should not be assignable to the type.</param>
            <param name="becauseArgs"></param>
            <returns>An <see cref="T:FluentAssertions.AndConstraint`1"/> which can be used to chain assertions.</returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.GetFailureMessageIfTypesAreDifferent(System.Type,System.Type)">
            <summary>
            Creates an error message in case the specified <paramref name="actual"/> type differs from the
            <paramref name="expected"/> type.
            </summary>
            <returns>
            An empty <see cref="T:System.String"/> if the two specified types are the same, or an error message that describes that
            the two specified types are not the same.
            </returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBe``1(System.String,System.Object[])">
            <summary>
            Asserts that the current type is not equal to the specified <typeparamref name="TUnexpected"/> type.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBe(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current type is not equal to the specified <paramref name="unexpected"/> type.
            </summary>
            <param name="unexpected">The unexpected type</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWithOrInherit``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with, or inherits from a parent class, the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDecoratedWithOrInherit``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with, or inherits from a parent class, an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDecoratedWithOrInherit``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with and does not inherit from a parent class,  the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDecoratedWithOrInherit``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with and does not inherit from a parent class, an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Implement(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> implements Interface <paramref name="interfaceType"/>.
            </summary>
            <param name="interfaceType">The interface that should be implemented.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.Implement``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> implements Interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface that should be implemented.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotImplement(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not implement Interface <paramref name="interfaceType"/>.
            </summary>
            <param name="interfaceType">The interface that should be not implemented.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotImplement``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> does not implement Interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface that should not be implemented.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDerivedFrom(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is derived from <see cref="T:System.Type"/> <paramref name="baseType"/>.
            </summary>
            <param name="baseType">The Type that should be derived from.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeDerivedFrom``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is derived from <typeparamref name="TBaseClass"/>.
            </summary>
            <typeparam name="TBaseClass">The Type that should be derived from.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDerivedFrom(System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not derived from <see cref="T:System.Type"/> <paramref name="baseType"/>.
            </summary>
            <param name="baseType">The Type that should not be derived from.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeDerivedFrom``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not derived from <typeparamref name="TBaseClass"/>.
            </summary>
            <typeparam name="TBaseClass">The Type that should not be derived from.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeSealed(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is sealed.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeSealed(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not sealed.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeAbstract(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is abstract.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeAbstract(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not abstract.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.BeStatic(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is static.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotBeStatic(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not static.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <returns></returns>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveProperty(System.Type,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type has a property of type <paramref name="propertyType"/> named <paramref name="name"/>.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <param name="propertyType">The type of the property.</param>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveProperty``1(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type has a property of type <typeparamref name="TProperty"/> named <paramref name="name"/>.
            </summary>
            <typeparam name="TProperty">The type of the property.</typeparam>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveProperty(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have a property named <paramref name="name"/>.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitProperty(System.Type,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type explicitly implements a property named
            <paramref name="name"/> from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitProperty``1(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type explicitly implements a property named
            <paramref name="name"/> from interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is being explicitly implemented.</typeparam>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitProperty(System.Type,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type does not explicitly implement a property named
            <paramref name="name"/> from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitProperty``1(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current type does not explicitly implement a property named
            <paramref name="name"/> from interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is not being explicitly implemented.</typeparam>
            <param name="name">The name of the property.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitMethod(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type explicitly implements a method named <paramref name="name"/>
            from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplicitMethod``1(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type explicitly implements a method named <paramref name="name"/>
            from interface  <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is being explicitly implemented.</typeparam>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitMethod(System.Type,System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type does not explicitly implement a method named <paramref name="name"/>
            from interface <paramref name="interfaceType" />.
            </summary>
            <param name="interfaceType">The type of the interface.</param>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplicitMethod``1(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type does not explicitly implement a method named <paramref name="name"/>
            from interface <typeparamref name="TInterface"/>.
            </summary>
            <typeparam name="TInterface">The interface whose member is not being explicitly implemented.</typeparam>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The expected types of the method parameters.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveIndexer(System.Type,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type has an indexer of type <paramref name="indexerType"/>.
            with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="indexerType">The type of the indexer.</param>
            <param name="parameterTypes">The parameter types for the indexer.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveIndexer(System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have an indexer that takes parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <param name="parameterTypes">The expected indexer's parameter types.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveMethod(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type has a method named <paramref name="name"/>with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The parameter types for the indexer.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveMethod(System.String,System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type does not expose a method named <paramref name="name"/>
            with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="name">The name of the method.</param>
            <param name="parameterTypes">The method parameter types.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveConstructor(System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type has a constructor with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <param name="parameterTypes">The parameter types for the indexer.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveDefaultConstructor(System.String,System.Object[])">
            <summary>
            Asserts that the current type has a default constructor.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveConstructor(System.Collections.Generic.IEnumerable{System.Type},System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have a constructor with parameter types <paramref name="parameterTypes"/>.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
            <param name="parameterTypes">The parameter types for the indexer.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveDefaultConstructor(System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have a default constructor.
            </summary>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected type has the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The expected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveAccessModifier(FluentAssertions.Common.CSharpAccessModifier,System.String,System.Object[])">
            <summary>
            Asserts that the selected type does not have the specified C# <paramref name="accessModifier"/>.
            </summary>
            <param name="accessModifier">The unexpected C# access modifier.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveImplictConversionOperator``2(System.String,System.Object[])">
            <summary>
            Asserts that the current type has an implicit conversion operator that converts <typeparamref name="TSource"/> into <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The type to convert from.</typeparam>
            <typeparam name="TTarget">The type to convert to.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveImplictConversionOperator(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current type has an implicit conversion operator that converts <paramref name="sourceType"/> into <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The type to convert from.</param>
            <param name="targetType">The type to convert to.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveImplictConversionOperator``2(System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have an implicit conversion operator that converts <typeparamref name="TSource"/> into <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The type to convert from.</typeparam>
            <typeparam name="TTarget">The type to convert to.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveImplictConversionOperator(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have an implicit conversion operator that converts <paramref name="sourceType"/> into <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The type to convert from.</param>
            <param name="targetType">The type to convert to.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplictConversionOperator``2(System.String,System.Object[])">
            <summary>
            Asserts that the current type has an explicit conversion operator that converts <typeparamref name="TSource"/> into <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The type to convert from.</typeparam>
            <typeparam name="TTarget">The type to convert to.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.HaveExplictConversionOperator(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current type has an explicit conversion operator that converts <paramref name="sourceType"/> into <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The type to convert from.</param>
            <param name="targetType">The type to convert to.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplictConversionOperator``2(System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have an explicit conversion operator that converts <typeparamref name="TSource"/> into <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The type to convert from.</typeparam>
            <typeparam name="TTarget">The type to convert to.</typeparam>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="M:FluentAssertions.Types.TypeAssertions.NotHaveExplictConversionOperator(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Asserts that the current type does not have an explicit conversion operator that converts <paramref name="sourceType"/> into <paramref name="targetType"/>.
            </summary>
            <param name="sourceType">The type to convert from.</param>
            <param name="targetType">The type to convert to.</param>
            <param name="because">A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])"/> explaining why the assertion
                        is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.</param>
            <param name="becauseArgs">Zero or more objects to format using the placeholders in <see cref="!:because"/>.</param>
        </member>
        <member name="P:FluentAssertions.Types.TypeAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Types.TypeSelector">
            <summary>
            Allows for fluent filtering a list of types.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ToArray">
            <summary>
            The resulting <see cref="T:System.Type"/> objects.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatDeriveFrom``1">
            <summary>
            Determines whether a type is a subclass of another type, but NOT the same type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatDoNotDeriveFrom``1">
            <summary>
            Determines whether a type is not a subclass of another type.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatImplement``1">
            <summary>
            Determines whether a type implements an interface (but is not the interface itself).
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatDoNotImplement``1">
            <summary>
            Determines whether a type does not implement an interface (but is not the interface itself).
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreDecoratedWith``1">
            <summary>
            Determines whether a type is decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreDecoratedWithOrInherit``1">
            <summary>
            Determines whether a type is decorated with, or inherits from a parent class, a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotDecoratedWith``1">
            <summary>
            Determines whether a type is not decorated with a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotDecoratedWithOrInherit``1">
            <summary>
            Determines whether a type is not decorated with and does not inherit from a parent class, a particular attribute.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreInNamespace(System.String)">
            <summary>
            Determines whether the namespace of type is exactly <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotInNamespace(System.String)">
            <summary>
            Determines whether the namespace of type is exactly not <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreUnderNamespace(System.String)">
            <summary>
            Determines whether the namespace of type starts with <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.ThatAreNotUnderNamespace(System.String)">
            <summary>
            Determines whether the namespace of type does not start with <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:FluentAssertions.Types.TypeSelectorAssertions">
            <summary>
            Contains a number of methods to assert that all <see cref="T:System.Type"/>s in a <see cref="T:FluentAssertions.Types.TypeSelector"/>
            meet certain expectations.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.#ctor(System.Type[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="P:FluentAssertions.Types.TypeSelectorAssertions.Subject">
            <summary>
            Gets the object which value is being asserted.
            </summary>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWithOrInherit``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with, or inherits from a parent class, the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.BeDecoratedWithOrInherit``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is decorated with, or inherits from a parent class, an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeDecoratedWith``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeDecoratedWith``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeDecoratedWithOrInherit``1(System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with and does not inherit from a parent class, the specified <typeparamref name="TAttribute"/>.
            </summary>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Types.TypeSelectorAssertions.NotBeDecoratedWithOrInherit``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Type"/> is not decorated with and does not inherit from a parent class,  an attribute of type <typeparamref name="TAttribute"/>
            that matches the specified <paramref name="isMatchingAttributePredicate"/>.
            </summary>
            <param name="isMatchingAttributePredicate">
            The predicate that the attribute must match.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Xml.XAttributeAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.Linq.XAttribute"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.#ctor(System.Xml.Linq.XAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Xml.XAttributeAssertions" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.Be(System.Xml.Linq.XAttribute)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XAttribute"/> equals the <paramref name="expected"/> attribute.
            </summary>
            <param name="expected">The expected attribute</param>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.Be(System.Xml.Linq.XAttribute,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XAttribute"/> equals the <paramref name="expected"/> attribute.
            </summary>
            <param name="expected">The expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.NotBe(System.Xml.Linq.XAttribute)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XAttribute"/> does not equal the <paramref name="unexpected"/> attribute,
            using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected attribute</param>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.NotBe(System.Xml.Linq.XAttribute,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XAttribute"/> does not equal the <paramref name="unexpected"/> attribute,
            using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.HaveValue(System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XAttribute"/> has the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
        </member>
        <member name="M:FluentAssertions.Xml.XAttributeAssertions.HaveValue(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XAttribute"/> has the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Xml.XAttributeAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Xml.XDocumentAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.Linq.XDocument"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.#ctor(System.Xml.Linq.XDocument)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Xml.XDocumentAssertions" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.Be(System.Xml.Linq.XDocument)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> equals the <paramref name="expected"/> document,
            using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected document</param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.Be(System.Xml.Linq.XDocument,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> equals the <paramref name="expected"/> document,
            using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="expected">The expected document</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.NotBe(System.Xml.Linq.XDocument)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> does not equal the <paramref name="unexpected"/> document,
            using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected document</param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.NotBe(System.Xml.Linq.XDocument,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> does not equal the <paramref name="unexpected"/> document,
            using its <see cref="M:System.Object.Equals(System.Object)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected document</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.BeEquivalentTo(System.Xml.Linq.XDocument)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> is equivalent to the <paramref name="expected"/> document,
            using its <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" /> implementation.
            </summary>
            <param name="expected">The expected document</param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.BeEquivalentTo(System.Xml.Linq.XDocument,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> is equivalent to the <paramref name="expected"/> document,
            using its <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" /> implementation.
            </summary>
            <param name="expected">The expected document</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.NotBeEquivalentTo(System.Xml.Linq.XDocument)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> is not equivalent to the <paramref name="unexpected"/> document,
            using its <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected document</param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.NotBeEquivalentTo(System.Xml.Linq.XDocument,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> is not equivalent to the <paramref name="unexpected"/> document,
            using its <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" /> implementation.
            </summary>
            <param name="unexpected">The unexpected document</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveRoot(System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> has a root element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name of the expected root element of the current document.</param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveRoot(System.Xml.Linq.XName)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> has a root element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name of the expected root element of the current document.</param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveRoot(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> has a root element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name of the expected root element of the current document.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveRoot(System.Xml.Linq.XName,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XDocument"/> has a root element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The full name <see cref="T:System.Xml.Linq.XName"/> of the expected root element of the current document.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveElement(System.String)">
            <summary>
            Asserts that the <see cref="P:System.Xml.Linq.XDocument.Root"/> element of the current <see cref="T:System.Xml.Linq.XDocument"/> has a direct
            child element with the specified <paramref name="expected"/> name.
            </summary>
            <param name="expected">
            The name of the expected child element of the current document's Root <see cref="P:System.Xml.Linq.XDocument.Root"/> element.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveElement(System.Xml.Linq.XName)">
            <summary>
            Asserts that the <see cref="P:System.Xml.Linq.XDocument.Root"/> element of the current <see cref="T:System.Xml.Linq.XDocument"/> has a direct
            child element with the specified <paramref name="expected"/> name.
            </summary>
            <param name="expected">
            The full name <see cref="T:System.Xml.Linq.XName"/> of the expected child element of the current document's Root <see cref="P:System.Xml.Linq.XDocument.Root"/> element.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveElement(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="P:System.Xml.Linq.XDocument.Root"/> element of the current <see cref="T:System.Xml.Linq.XDocument"/> has a direct
            child element with the specified <paramref name="expected"/> name.
            </summary>
            <param name="expected">
            The name of the expected child element of the current document's Root <see cref="P:System.Xml.Linq.XDocument.Root"/> element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XDocumentAssertions.HaveElement(System.Xml.Linq.XName,System.String,System.Object[])">
            <summary>
            Asserts that the <see cref="P:System.Xml.Linq.XDocument.Root"/> element of the current <see cref="T:System.Xml.Linq.XDocument"/> has a direct
            child element with the specified <paramref name="expected"/> name.
            </summary>
            <param name="expected">
            The full name <see cref="T:System.Xml.Linq.XName"/> of the expected child element of the current document's Root <see cref="P:System.Xml.Linq.XDocument.Root"/> element.
            </param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Xml.XDocumentAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Xml.XElementAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.Linq.XElement"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.#ctor(System.Xml.Linq.XElement)">
            <summary>
            Initializes a new instance of the <see cref="T:FluentAssertions.Xml.XElementAssertions" /> class.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.Be(System.Xml.Linq.XElement)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> equals the
            <paramref name="expected"/> element, by using
            <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)"/>
            </summary>
            <param name="expected">The expected element</param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.Be(System.Xml.Linq.XElement,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> equals the
            <paramref name="expected"/> element, by using
            <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)"/>
            </summary>
            <param name="expected">The expected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.NotBe(System.Xml.Linq.XElement)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> does not equal the
            <paramref name="unexpected"/> element, using
            <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />.
            </summary>
            <param name="unexpected">The unexpected element</param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.NotBe(System.Xml.Linq.XElement,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> does not equal the
            <paramref name="unexpected"/> element, using
            <see cref="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />.
            </summary>
            <param name="unexpected">The unexpected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.BeEquivalentTo(System.Xml.Linq.XElement)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> is equivalent to the
            <paramref name="expected"/> element, using a semantic equivalency
            comparison.
            </summary>
            <param name="expected">The expected element</param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.BeEquivalentTo(System.Xml.Linq.XElement,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> is equivalent to the
            <paramref name="expected"/> element, using a semantic equivalency
            comparison.
            </summary>
            <param name="expected">The expected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.NotBeEquivalentTo(System.Xml.Linq.XElement)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> is not equivalent to
            the <paramref name="unexpected"/> element, using a semantic
            equivalency comparison.
            </summary>
            <param name="unexpected">The unexpected element</param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.NotBeEquivalentTo(System.Xml.Linq.XElement,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> is not equivalent to
            the <paramref name="unexpected"/> element, using a semantic
            equivalency comparison.
            </summary>
            <param name="unexpected">The unexpected element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveValue(System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveValue(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has the specified <paramref name="expected"/> value.
            </summary>
            <param name="expected">The expected value</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveAttribute(System.String,System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has an attribute with the specified <paramref name="expectedName"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveAttribute(System.Xml.Linq.XName,System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has an attribute with the specified <paramref name="expectedName"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name <see cref="T:System.Xml.Linq.XName"/> of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveAttribute(System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has an attribute with the specified <paramref name="expectedName"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveAttribute(System.Xml.Linq.XName,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has an attribute with the specified <paramref name="expectedName"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name <see cref="T:System.Xml.Linq.XName"/> of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveElement(System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has a direct child element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name of the expected child element</param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveElement(System.Xml.Linq.XName)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has a direct child element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name <see cref="T:System.Xml.Linq.XName"/> of the expected child element</param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveElement(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has a direct child element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name <see cref="T:System.Xml.Linq.XName"/> of the expected child element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XElementAssertions.HaveElement(System.Xml.Linq.XName,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.Linq.XElement"/> has a direct child element with the specified
            <paramref name="expected"/> name.
            </summary>
            <param name="expected">The name <see cref="T:System.Xml.Linq.XName"/> of the expected child element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="P:FluentAssertions.Xml.XElementAssertions.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="T:FluentAssertions.Xml.XmlElementAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.XmlElement"/>
            is in the expected state./>
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.#ctor(System.Xml.XmlElement)">
            <summary>
            Initialized a new instance of the <see cref="T:FluentAssertions.Xml.XmlElementAssertions"/>
            class.
            </summary>
            <param name="xmlElement"></param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveInnerText(System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has the specified
            <paramref name="expected"/> inner text.
            </summary>
            <param name="expected">The expected value.</param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveInnerText(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has the specified
            <paramref name="expected"/> inner text.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveAttribute(System.String,System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has an attribute
            with the specified <paramref name="expectedName"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveAttribute(System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has an attribute
            with the specified <paramref name="expectedName"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveAttributeWithNamespace(System.String,System.String,System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has an attribute
            with the specified <paramref name="expectedName"/>, <param name="expectedNamespace"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveAttributeWithNamespace(System.String,System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has an attribute
            with the specified <paramref name="expectedName"/>, <param name="expectedNamespace"/>
            and <paramref name="expectedValue"/>.
            </summary>
            <param name="expectedName">The name of the expected attribute</param>
            <param name="expectedValue">The value of the expected attribute</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveElement(System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has a direct child element with the specified
            <paramref name="expectedName"/> name.
            </summary>
            <param name="expectedName">The name of the expected child element</param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveElement(System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has a direct child element with the specified
            <paramref name="expectedName"/> name.
            </summary>
            <param name="expectedName">The name of the expected child element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveElementWithNamespace(System.String,System.String)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has a direct child element with the specified
            <paramref name="expectedName"/> name and <paramref name="expectedNamespace" /> namespace.
            </summary>
            <param name="expectedName">The name of the expected child element</param>
            <param name="expectedNamespace">The namespace of the expected child element</param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlElementAssertions.HaveElementWithNamespace(System.String,System.String,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlElement"/> has a direct child element with the specified
            <paramref name="expectedName"/> name and <paramref name="expectedNamespace" /> namespace.
            </summary>
            <param name="expectedName">The name of the expected child element</param>
            <param name="expectedNamespace">The namespace of the expected child element</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="becauseArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="T:FluentAssertions.Xml.XmlNodeAssertions">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.XmlNode"/> is in the expected state.
            </summary>
        </member>
        <member name="T:FluentAssertions.Xml.XmlNodeAssertions`2">
            <summary>
            Contains a number of methods to assert that an <see cref="T:System.Xml.XmlNode"/> is in the expected state.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XmlNodeAssertions`2.BeEquivalentTo(System.Xml.XmlNode)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlNode"/> is equivalent to the <paramref name="expected"/> element.
            </summary>
            <param name="expected">The expected element</param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlNodeAssertions`2.BeEquivalentTo(System.Xml.XmlNode,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlNode"/> is equivalent to the <paramref name="expected"/> node.
            </summary>
            <param name="expected">The expected node</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlNodeAssertions`2.NotBeEquivalentTo(System.Xml.XmlNode)">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlNode"/> is not equivalent to
            the <paramref name="unexpected"/> node.
            </summary>
            <param name="unexpected">The unexpected node</param>
        </member>
        <member name="M:FluentAssertions.Xml.XmlNodeAssertions`2.NotBeEquivalentTo(System.Xml.XmlNode,System.String,System.Object[])">
            <summary>
            Asserts that the current <see cref="T:System.Xml.XmlNode"/> is not equivalent to
            the <paramref name="unexpected"/> node.
            </summary>
            <param name="unexpected">The unexpected node</param>
            <param name="because">
            A formatted phrase as is supported by <see cref="M:System.String.Format(System.String,System.Object[])" /> explaining why the assertion
            is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
            </param>
            <param name="reasonArgs">
            Zero or more objects to format using the placeholders in <see cref="!:because" />.
            </param>
            <returns></returns>
        </member>
        <member name="P:FluentAssertions.Xml.XmlNodeAssertions`2.Identifier">
            <summary>
            Returns the type of the subject the assertion applies on.
            </summary>
        </member>
        <member name="M:FluentAssertions.Xml.XmlNodeFormatter.Format(System.Object,FluentAssertions.Formatting.FormattingContext,FluentAssertions.Formatting.FormatChild)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example><code>
            [CanBeNull] object Test() => null;
            
            void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ItemNotNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitNotNullAttribute">
            <summary>
            Implicitly apply [NotNull]/[ItemNotNull] annotation to all the of type members and parameters
            in particular scope where this annotation is used (type declaration or whole assembly).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            void ShowError(string message, params object[] args) { /* do something */ }
            
            void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.Annotations.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
             
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) {  }
            
               string _name;
             
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methods doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            
            class UsesNoEquality {
              void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            class ComponentAttribute : Attribute { }
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
            as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:JetBrains.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example><code>
            [Pure] int Multiply(int x, int y) => x * y;
            
            void M() {
              Multiply(123, 42); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of method invocation must be used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ProvidesContextAttribute">
            <summary>
            Indicates the type member or parameter of some type, that should be used instead of all other ways
            to get the value that type. This annotation is useful when you have some "context" value evaluated
            and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
            </summary>
            <example><code>
            class Foo {
              [ProvidesContext] IBarService _barService = ;
            
              void ProcessNode(INode node) {
                DoSomething(node, node.GetGlobalServices().Bar);
                //              ^ Warning: use value of '_barService' field
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.SourceTemplateAttribute">
            <summary>
            An extension method marked with this attribute is processed by ReSharper code completion
            as a 'Source Template'. When extension method is completed over some expression, it's source code
            is automatically expanded like a template at call site.
            </summary>
            <remarks>
            Template method body can contain valid source code and/or special comments starting with '$'.
            Text inside these comments is added as source code when the template is applied. Template parameters
            can be used either as additional method parameters or as identifiers wrapped in two '$' signs.
            Use the <see cref="T:JetBrains.Annotations.MacroAttribute"/> attribute to specify macros for parameters.
            </remarks>
            <example>
            In this example, the 'forEach' method is a source template available over all values
            of enumerable types, producing ordinary C# 'foreach' statement and placing caret inside block:
            <code>
            [SourceTemplate]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; xs) {
              foreach (var x in xs) {
                 //$ $END$
              }
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.MacroAttribute">
            <summary>
            Allows specifying a macro for a parameter of a <see cref="T:JetBrains.Annotations.SourceTemplateAttribute">source template</see>.
            </summary>
            <remarks>
            You can apply the attribute on the whole method or on any of its additional parameters. The macro expression
            is defined in the <see cref="P:JetBrains.Annotations.MacroAttribute.Expression"/> property. When applied on a method, the target
            template parameter is defined in the <see cref="P:JetBrains.Annotations.MacroAttribute.Target"/> property. To apply the macro silently
            for the parameter, set the <see cref="P:JetBrains.Annotations.MacroAttribute.Editable"/> property value = -1.
            </remarks>
            <example>
            Applying the attribute on a source template method:
            <code>
            [SourceTemplate, Macro(Target = "item", Expression = "suggestVariableName()")]
            public static void forEach&lt;T&gt;(this IEnumerable&lt;T&gt; collection) {
              foreach (var item in collection) {
                //$ $END$
              }
            }
            </code>
            Applying the attribute on a template method parameter:
            <code>
            [SourceTemplate]
            public static void something(this Entity x, [Macro(Expression = "guid()", Editable = -1)] string newguid) {
              /*$ var $x$Id = "$newguid$" + x.ToString();
              x.DoSomething($x$Id); */
            }
            </code>
            </example>
        </member>
        <member name="P:JetBrains.Annotations.MacroAttribute.Expression">
            <summary>
            Allows specifying a macro that will be executed for a <see cref="T:JetBrains.Annotations.SourceTemplateAttribute">source template</see>
            parameter when the template is expanded.
            </summary>
        </member>
        <member name="P:JetBrains.Annotations.MacroAttribute.Editable">
            <summary>
            Allows specifying which occurrence of the target parameter becomes editable when the template is deployed.
            </summary>
            <remarks>
            If the target parameter is used several times in the template, only one occurrence becomes editable;
            other occurrences are changed synchronously. To specify the zero-based index of the editable occurrence,
            use values >= 0. To make the parameter non-editable when the template is expanded, use -1.
            </remarks>>
        </member>
        <member name="P:JetBrains.Annotations.MacroAttribute.Target">
            <summary>
            Identifies the target parameter of a <see cref="T:JetBrains.Annotations.SourceTemplateAttribute">source template</see> if the
            <see cref="T:JetBrains.Annotations.MacroAttribute"/> is applied on a template method.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is
            an MVC controller. If applied to a method, the MVC controller name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type. Use this attribute
            for custom wrappers similar to <c>System.Web.Mvc.Controller.View(String, Object)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter is an MVC
            partial view. If applied to a method, the MVC partial view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcSuppressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling inspections for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewComponentAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component name.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewComponentViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view component view. If applied to a method, the MVC view component view name is default.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name.
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how method, constructor invocation or property access
            over collection type affects content of the collection.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with 
            <see cref="T:JetBrains.Annotations.AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. The method itself should be
            marked by <see cref="T:JetBrains.Annotations.AssertionMethodAttribute"/> attribute. The mandatory argument of
            the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisfies the condition,
            then the execution continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:JetBrains.Annotations.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.XamlItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the type that has <c>ItemsSource</c> property and should be treated
            as <c>ItemsControl</c>-derived type, to enable inner items <c>DataContext</c> type resolve.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.XamlItemBindingOfItemsControlAttribute">
            <summary>
            XAML attribute. Indicates the property of some <c>BindingBase</c>-derived type, that
            is used to bind some item of <c>ItemsControl</c>-derived type. This annotation will
            enable the <c>DataContext</c> type resolve for XAML bindings for such properties.
            </summary>
            <remarks>
            Property should have the tree ancestor of the <c>ItemsControl</c> type or
            marked with the <see cref="T:JetBrains.Annotations.XamlItemsControlAttribute"/> attribute.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.NoReorder">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns
            </remarks>
        </member>
    </members>
</doc>
